<documents>
<document index="1">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\config.py</source>
<document_content>
import os
from dotenv import load_dotenv
from utils.error_handling import handle_error, critical_error

script_dir = os.path.dirname(os.path.abspath(__file__))
project_dir = os.path.dirname(script_dir)
dotenv_path = os.path.join(project_dir, '.env')

def reload_env():
    load_dotenv(dotenv_path, override=True)

reload_env()

class Config:
    MT5_LOGIN = os.getenv("MT5_LOGIN")
    if not MT5_LOGIN:
        raise ValueError("MT5_LOGIN environment variable is not set.")

    MT5_PASSWORD = os.getenv("MT5_PASSWORD")
    if not MT5_PASSWORD:
        raise ValueError("MT5_PASSWORD environment variable is not set.")

    MT5_SERVER = os.getenv("MT5_SERVER")
    if not MT5_SERVER:
        raise ValueError("MT5_SERVER environment variable is not set.")

    MT5_PATH = os.getenv("MT5_PATH")
    if not MT5_PATH:
        raise ValueError("MT5_PATH environment variable is not set.")

    MT5_TIMEFRAME = os.getenv("MT5_TIMEFRAME")
    if MT5_TIMEFRAME not in ["M1", "M5", "M15", "M30", "H1", "H4", "D1"]:
        raise ValueError(f"Invalid MT5_TIMEFRAME value: {MT5_TIMEFRAME}. Expected values: M1, M5, M15, M30, H1, H4, D1.")

    SYMBOLS = os.getenv("SYMBOLS")
    if SYMBOLS:
        SYMBOLS = SYMBOLS.split(",")
    else:
        raise ValueError("SYMBOLS environment variable is not set.")

    TELEGRAM_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    TELEGRAM_IDS = os.getenv("TELEGRAM_IDS")
    if TELEGRAM_TOKEN and TELEGRAM_IDS:
        TELEGRAM_IDS = TELEGRAM_IDS.split(",")
    else:
        TELEGRAM_TOKEN = None
        TELEGRAM_IDS = None

    try:
        MIN_TP_PROFIT = float(os.getenv("MIN_TP_PROFIT", 50.0))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid MIN_TP_PROFIT value: {os.getenv('MIN_TP_PROFIT')}. Expected a numeric value.")

    try:
        MAX_LOSS_PER_DAY = float(os.getenv("MAX_LOSS_PER_DAY", 1000.0))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid MAX_LOSS_PER_DAY value: {os.getenv('MAX_LOSS_PER_DAY')}. Expected a numeric value.")

    try:
        STARTING_EQUITY = float(os.getenv("STARTING_EQUITY", 10000.0))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid STARTING_EQUITY value: {os.getenv('STARTING_EQUITY')}. Expected a numeric value.")

    try:
        LIMIT_NO_OF_TRADES = int(os.getenv("LIMIT_NO_OF_TRADES", 5))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid LIMIT_NO_OF_TRADES value: {os.getenv('LIMIT_NO_OF_TRADES')}. Expected an integer value.")

    try:
        RISK_PER_TRADE = float(os.getenv("RISK_PER_TRADE", 0.01))
    except ValueError:
        raise ValueError(f"Invalid RISK_PER_TRADE value: {os.getenv('RISK_PER_TRADE')}. Expected a numeric value.")

    if not 0 < RISK_PER_TRADE <= 1:
        raise ValueError(f"RISK_PER_TRADE value must be between 0 and 1. Current value: {RISK_PER_TRADE}")

    try:
        PIP_VALUE = float(os.getenv("PIP_VALUE", 0.0001))
    except ValueError:
        raise ValueError(f"Invalid PIP_VALUE value: {os.getenv('PIP_VALUE')}. Expected a numeric value.")

    @classmethod
    def validate(cls):
        try:
            required_vars = [
                'MT5_LOGIN', 'MT5_PASSWORD', 'MT5_SERVER', 'MT5_PATH',
                'MT5_TIMEFRAME', 'SYMBOLS'
            ]
            for var in required_vars:
                if not getattr(cls, var, None):
                    raise ValueError(f"Missing required environment variable: {var}")

            numeric_vars = ['MIN_TP_PROFIT', 'MAX_LOSS_PER_DAY', 'STARTING_EQUITY', 'RISK_PER_TRADE', 'PIP_VALUE']
            for var in numeric_vars:
                if not isinstance(getattr(cls, var, None), (int, float)):
                    raise ValueError(f"Invalid value for {var}. Expected a numeric value.")

            if not isinstance(cls.LIMIT_NO_OF_TRADES, int):
                raise ValueError(f"Invalid value for LIMIT_NO_OF_TRADES. Expected an integer value.")

        except ValueError as e:
            handle_error(e, "Configuration validation failed")
            critical_error(e, "Invalid configuration settings")

try:
    Config.validate()
except Exception as e:
    handle_error(e, "Error occurred during configuration validation")
    raise
</document_content>
</document>

<document index="2">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\generate_code_document.py</source>
<document_content>
import os

def generate_code_document(root_dir):
    document = "<documents>\n"
    index = 1

    for root, dirs, files in os.walk(root_dir):
        for file in files:
            if file.endswith(".py"):
                file_path = os.path.join(root, file)
                with open(file_path, "r") as f:
                    file_content = f.read()

                document += f"<document index=\"{index}\">\n"
                document += f"<source>{file_path}</source>\n"
                document += "<document_content>\n"
                document += file_content
                document += "\n</document_content>\n"
                document += "</document>\n\n"
                index += 1

    document += "</documents>"
    return document

if __name__ == "__main__":
    # Specify the root directory of your repository
    root_directory = r"C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot"

    # Generate the code document
    code_document = generate_code_document(root_directory)

    # Specify the output file path
    output_file = os.path.join(root_directory, "code_document.xml")

    # Save the code document to a file
    with open(output_file, "w") as file:
        file.write(code_document)

    print(f"Code document saved to: {output_file}")

</document_content>
</document>

<document index="3">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\main.py</source>
<document_content>
import MetaTrader5 as mt5
from config import Config
from metatrader.connection import initialize_mt5, shutdown_mt5
from metatrader.data_retrieval import get_historical_data
from strategy.tunnel_strategy import run_strategy
from backtesting.backtest import run_backtest
from utils.logger import setup_logging
from utils.error_handling import handle_error

def main():
    try:
        # Set up logging
        setup_logging()

        # Initialize MetaTrader5
        if not initialize_mt5(Config.MT5_PATH):
            raise Exception("Failed to initialize MetaTrader5")

        # Run the trading strategy
        run_strategy(
            symbols=Config.SYMBOLS,
            mt5_init=mt5,
            timeframe=mt5.TIMEFRAME_M1,
            lot_size=0.01,
            min_take_profit=Config.MIN_TP_PROFIT,
            max_loss_per_day=Config.MAX_LOSS_PER_DAY,
            starting_equity=Config.STARTING_EQUITY,
            max_trades_per_day=Config.LIMIT_NO_OF_TRADES
        )

        # Run backtesting
        symbol = 'EURUSD'
        start_date = '2022-01-01'
        end_date = '2022-12-31'
        timeframe = mt5.H1
        initial_balance = 10000
        risk_percent = 0.02

        historical_data = get_historical_data(symbol, timeframe, start_date, end_date)
        if historical_data is None or len(historical_data) == 0:
            raise ValueError(f"No historical data retrieved for {symbol}")
    
        run_backtest(
            symbol=symbol,
            start_date=start_date,
            end_date=end_date,
            timeframe=timeframe,
            initial_balance=initial_balance,
            risk_percent=risk_percent,
            min_take_profit=Config.MIN_TP_PROFIT,
            max_loss_per_day=Config.MAX_LOSS_PER_DAY,
            starting_equity=Config.STARTING_EQUITY,
            max_trades_per_day=Config.LIMIT_NO_OF_TRADES
        )

    except Exception as e:
        handle_error(e, "An error occurred in the main function")

    finally:
        # Shutdown MetaTrader5
        shutdown_mt5()

if __name__ == '__main__':
    main()



# import signal
# import sys
# from scheduler import setup_schedule, run_scheduled_tasks
# from utils.error_handling import handle_error, critical_error
# from strategy.trade_logic import calculate_position_size, entry_long, entry_short, exit_trade
# from utils.data_validation import validate_data, sanitize_data
# from config import Config
# from metatrader.connection import initialize_mt5
# from metatrader.trade_management import get_open_positions, should_exit_position, generate_trade_signal
# from metatrader.connection import initialize_mt5, get_account_info


# def signal_handler(signum, frame):
#     critical_error("Signal received, shutting down", f"Signal handler triggered with signal: {signum}")
#     sys.exit(0)

# # Register the signal handler
# signal.signal(signal.SIGINT, signal_handler)

# def main():
#     signal.signal(signal.SIGINT, signal_handler)
#     signal.signal(signal.SIGTERM, signal_handler)

#     try:
#         setup_schedule()
        
#         if initialize_mt5():
#             account_info = get_account_info()
#             account_balance = account_info["balance"]

#             for symbol in Config.SYMBOLS:
#                 data = get_historical_data(symbol, Config.MT5_TIMEFRAME, start_time, end_time)
#                 sanitized_data = sanitize_data(data)

#                 if validate_data(sanitized_data, TradeRequestSchema.schema()):
#                     signal = generate_trade_signal(sanitized_data, period, deviation)
#                     price = sanitized_data["close"].iloc[-1]
#                     stop_loss_pips = 20
#                     take_profit_pips = 40
#                     deviation = 10
#                     magic = 12345
#                     comment = "Tunnel Strategy"

#                     position_size = calculate_position_size(account_balance, Config.RISK_PER_TRADE, stop_loss_pips, Config.PIP_VALUE)

#                     if signal == 'BUY':
#                         sl = price - (stop_loss_pips * Config.PIP_VALUE)
#                         tp = price + (take_profit_pips * Config.PIP_VALUE)
#                         entry_long(symbol, position_size, price, sl, tp, deviation, magic, comment)
#                     elif signal == 'SELL':
#                         sl = price + (stop_loss_pips * Config.PIP_VALUE)
#                         tp = price - (take_profit_pips * Config.PIP_VALUE)
#                         entry_short(symbol, position_size, price, sl, tp, deviation, magic, comment)
#                 else:
#                     logging.error("Invalid input data")

#             open_positions = get_open_positions()
#             for position in open_positions:
#                 if should_exit_position(position):
#                     exit_trade(position.ticket)

#         run_scheduled_tasks()

#     except Exception as e:
#         handle_error(e, "Failed to execute trading logic or validate/sanitize input data")

# if __name__ == "__main__":
#     main()
</document_content>
</document>

<document index="4">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\scheduler.py</source>
<document_content>
import schedule
import time
import logging
from strategy.tunnel_strategy import run_strategy
from metatrader.connection import initialize_mt5
from config import Config
from utils.error_handling import handle_error, warn_error
from strategy.trade_logic import calculate_position_size, entry_long, entry_short, exit_trade
from utils.data_validation import validate_data, sanitize_data
from metatrader.trade_management import get_open_positions, should_exit_position

def initialize_strategy():
    try:
        logging.info("Initializing strategy on server: %s", Config.MT5_SERVER)
        mt5_init = initialize_mt5(
            login=Config.MT5_LOGIN,
            password=Config.MT5_PASSWORD,
            server=Config.MT5_SERVER,
            path=Config.MT5_PATH,
        )

        run_strategy(
            symbols=Config.SYMBOLS,
            mt5_init=mt5_init,
            timeframe=Config.MT5_TIMEFRAME,
            lot_size=Config.MT5_LOT_SIZE,
            min_take_profit=Config.MIN_TP_PROFIT,
            max_loss_per_day=Config.MAX_LOSS_PER_DAY,
            starting_equity=Config.STARTING_EQUITY,
            max_traders_per_day=Config.LIMIT_NO_OF_TRADES
        )
    except Exception as e:
        warn_error(e, "Error initializing strategy")

def run_scheduled_tasks():
    while True:
        try:
            schedule.run_pending()
            time.sleep(1)
        except Exception as e:
            handle_error(e, "Error during scheduled task execution")

def run_trading_task():
    try:
        account_info = get_account_info()
        account_balance = account_info["balance"]

        for symbol in Config.SYMBOLS:
            data = get_historical_data(symbol, Config.MT5_TIMEFRAME, start_time, end_time)
            sanitized_data = sanitize_data(data)

            if validate_data(sanitized_data, TradeRequestSchema.schema()):
                signal = generate_trade_signal(sanitized_data, period, deviation)
                price = sanitized_data["close"].iloc[-1]
                stop_loss_pips = 20
                take_profit_pips = 40
                deviation = 10
                magic = 12345
                comment = "Tunnel Strategy"

                position_size = calculate_position_size(account_balance, Config.RISK_PER_TRADE, stop_loss_pips, Config.PIP_VALUE)

                if signal == 'BUY':
                    sl = price - (stop_loss_pips * Config.PIP_VALUE)
                    tp = price + (take_profit_pips * Config.PIP_VALUE)
                    entry_long(symbol, position_size, price, sl, tp, deviation, magic, comment)
                elif signal == 'SELL':
                    sl = price + (stop_loss_pips * Config.PIP_VALUE)
                    tp = price - (take_profit_pips * Config.PIP_VALUE)
                    entry_short(symbol, position_size, price, sl, tp, deviation, magic, comment)
            else:
                logging.error("Invalid input data")

        open_positions = get_open_positions()
        for position in open_positions:
            if should_exit_position(position):
                exit_trade(position.ticket)

    except Exception as e:
        handle_error(e, "Failed to execute trading task or validate/sanitize input data")

def setup_schedule():
    schedule.every().day.at("09:00").do(initialize_strategy)
    schedule.every(15).minutes.do(run_trading_task)
    logging.info("Scheduler setup complete. Next run at: %s", schedule.next_run())

def adjust_schedule(market_conditions):
    if market_conditions == 'volatile':
        schedule.every(5).minutes.do(run_trading_task)
    elif market_conditions == 'calm':
        schedule.every(30).minutes.do(run_trading_task)

# Call adjust_schedule() based on market conditions
market_conditions = analyze_market_conditions()
adjust_schedule(market_conditions)
</document_content>
</document>

<document index="5">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\backtesting\backtest.py</source>
<document_content>
import pandas as pd
from metatrader.data_retrieval import get_historical_data
from strategy.tunnel_strategy import generate_trade_signal, execute_trade, manage_position, calculate_position_size
from utils.plotting import plot_backtest_results

def run_backtest(symbol, start_date, end_date, timeframe, initial_balance, risk_percent, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day):
    # Retrieve historical data
    data = get_historical_data(symbol, timeframe, start_date, end_date)

    # Initialize variables
    balance = initial_balance
    trades = []

    # Backtesting loop
    for i in range(len(data)):
        # Calculate indicators and generate trading signals
        signal = generate_trade_signal(data.iloc[:i+1], period=20, deviation_factor=2.0)

        if signal == 'BUY':
            # Simulate trade entry
            trade = {
                'entry_time': data.iloc[i]['time'],
                'entry_price': data.iloc[i]['close'],
                'volume': calculate_position_size(balance, risk_percent)
            }
            trades.append(trade)
            execute_trade(trade)

        elif signal == 'SELL':
            # Simulate trade exit
            if trades:
                trade = trades[-1]
                trade['exit_time'] = data.iloc[i]['time']
                trade['exit_price'] = data.iloc[i]['close']
                trade['profit'] = (trade['exit_price'] - trade['entry_price']) * trade['volume']
                balance += trade['profit']
                execute_trade(trade)

        manage_position(symbol, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day)

    # Calculate performance metrics
    total_profit = balance - initial_balance
    num_trades = len(trades)
    win_rate = sum(1 for trade in trades if trade['profit'] > 0) / num_trades
    max_drawdown = calculate_max_drawdown(trades, initial_balance)

    # Print performance metrics
    print(f"Total Profit: {total_profit:.2f}")
    print(f"Number of Trades: {num_trades}")
    print(f"Win Rate: {win_rate:.2%}")
    print(f"Maximum Drawdown: {max_drawdown:.2f}")

    # Plot backtest results
    plot_backtest_results(data, trades)

def calculate_max_drawdown(trades, initial_balance):
    balance = initial_balance
    max_balance = initial_balance
    max_drawdown = 0

    for trade in trades:
        balance += trade['profit']
        max_balance = max(max_balance, balance)
        drawdown = max_balance - balance
        max_drawdown = max(max_drawdown, drawdown)

    return max_drawdown
</document_content>
</document>

<document index="6">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\ignore_extra_stuff\cleanup.py</source>
<document_content>
import re

# Read the script from a file
with open("output_script.py", "r") as file:
    script = file.read()

# Remove extra line spacing
script_cleaned = re.sub(r'\n\s*\n', '\n', script)

# Write the cleaned script back to the file
with open("output_script.py", "w") as file:
    file.write(script_cleaned)

</document_content>
</document>

<document index="7">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\ignore_extra_stuff\output_script.py</source>
<document_content>
# # First NoteBook Script - Showing Live Orders Placed
# # Connect to MetaTrader 5
import numpy as np
import pandas as pd
import MetaTrader5 as mt5
# Connect to the MetaTrader5 terminal
if not mt5.initialize():
    print("Failed to initialize MetaTrader5")
    mt5.shutdown()
else:
    print("MetaTrader5 initialized successfully")
# # Retrieve Historical Price Data
# Specify the symbol and timeframe
symbol = "EURUSD"
timeframe = mt5.TIMEFRAME_H1  # 1-hour timeframe
# Retrieve historical price data
print("Retrieving historical price data...")
num_bars = 1000  # Number of bars to retrieve
rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, num_bars)
# Convert the data to a pandas DataFrame
df = pd.DataFrame(rates, columns=['time', 'open', 'high', 'low', 'close', 'tick_volume', 'spread', 'real_volume'])
df['time'] = pd.to_datetime(df['time'], unit='s')
# Print the historical price data
print("Historical Price Data:")
print(df.head())
# # Calculate Indicators
# Implement the Wavy Tunnel and long-term EMA
def ema(data, period):
    ema_values = [None] * (period - 1)  # Initialize with None for the first period - 1 values
    sma = sum(data[:period]) / period
    ema_values.append(sma)
    multiplier = 2 / (period + 1)
    for price in data[period:]:
        ema = (price - ema_values[-1]) * multiplier + ema_values[-1]
        ema_values.append(ema)
    return ema_values
# User inputs
apply_threshold = True
threshold_values = {
    'USD': 2,
    'EUR': 2,
    'JPY': 300,
    'GBP': 6,
    'CHF': 2,
    'AUD': 2,
    'default': 100
}
# Wavy Tunnel
print("Calculating Wavy Tunnel indicator...")
df['wavy_h'] = ema(df['high'], 34)
df['wavy_c'] = ema(df['close'], 34)
df['wavy_l'] = ema(df['low'], 34)
df['tunnel1'] = ema(df['close'], 144)
df['tunnel2'] = ema(df['close'], 169)
# Print each Wavy Tunnel column
print("Wavy Tunnel High (wavy_h):")
print(df[['time', 'high', 'wavy_h']])
print("\nWavy Tunnel Close (wavy_c):")
print(df[['time', 'close', 'wavy_c']])
print("\nWavy Tunnel Low (wavy_l):")
print(df[['time', 'low', 'wavy_l']])
print("\nTunnel 1:")
print(df[['time', 'close', 'tunnel1']])
print("\nTunnel 2:")
print(df[['time', 'close', 'tunnel2']])
# Implement long-term EMA
print("Calculating long-term EMA...")
df['long_term_ema'] = ema(df['close'], 200)
# Print the DataFrame with long-term EMA
print("DataFrame with long-term EMA:")
print(df[['time', 'close', 'long_term_ema']])
# # Detect Peaks and Dips
# Implement peak and dip detection
def detect_peaks_and_dips(df, peak_type):
    peaks = []
    dips = []
    for i in range(len(df)):
        is_peak = True
        is_dip = True
        for j in range(peak_type):
            start_index = max(0, i - j)
            end_index = min(len(df) - 1, i + j)
            if df['high'][i] <= df['high'][start_index] or df['high'][i] <= df['high'][end_index]:
                is_peak = False
            if df['low'][i] >= df['low'][start_index] or df['low'][i] >= df['low'][end_index]:
                is_dip = False
        if is_peak:
            peaks.append(df['high'][i])
        if is_dip:
            dips.append(df['low'][i])
    return peaks, dips
print("Detecting peaks and dips...")
peaks, dips = detect_peaks_and_dips(df, peak_type)
# Print the peaks and dips
print("Peaks:")
for peak in peaks:
    print(peak)
print("\nDips:")
for dip in dips:
    print(dip)
# # Generate Entry Signals
## Implement entry conditions
def check_entry_conditions(row):
    buy_condition = (
        row['close'] > max(row['wavy_c'], row['wavy_h'], row['wavy_l']) and
        min(row['wavy_c'], row['wavy_h'], row['wavy_l']) > max(row['tunnel1'], row['tunnel2'])
    )
    sell_condition = (
        row['close'] < min(row['wavy_c'], row['wavy_h'], row['wavy_l']) and
        max(row['wavy_c'], row['wavy_h'], row['wavy_l']) < min(row['tunnel1'], row['tunnel2'])
    )
    if apply_threshold:
        threshold = threshold_values.get(symbol[:3], threshold_values['default']) * mt5.symbol_info(symbol).trade_tick_size
        buy_condition &= row['close'] > max(row['wavy_c'], row['wavy_h'], row['wavy_l']) + threshold
        sell_condition &= row['close'] < min(row['wavy_c'], row['wavy_h'], row['wavy_l']) - threshold
    return buy_condition, sell_condition
df['buy_signal'], df['sell_signal'] = zip(*df.apply(check_entry_conditions, axis=1))
# Print the entry signals
print("Checking entry conditions...")
print("Entry Signals:")
print(df[['time', 'close', 'buy_signal', 'sell_signal']])
# Showcase the buy and sell signals
def print_signals(df):
    buy_signals = df[df['buy_signal'] == True]
    sell_signals = df[df['sell_signal'] == True]
    print("Buy Signals:")
    print(buy_signals[['time', 'close', 'buy_signal']])
    print("\nSell Signals:")
    print(sell_signals[['time', 'close', 'sell_signal']])
print_signals(df)
# # Plotting
import matplotlib.pyplot as plt
# Plotting the price data and indicators
plt.figure(figsize=(16, 8))
plt.subplot(2, 1, 1)
plt.plot(df['time'], df['close'], label='Close Price')
plt.plot(df['time'], df['wavy_c'], label='Wavy Tunnel Close')
plt.plot(df['time'], df['wavy_h'], label='Wavy Tunnel High')
plt.plot(df['time'], df['wavy_l'], label='Wavy Tunnel Low')
plt.plot(df['time'], df['tunnel1'], label='Tunnel 1')
plt.plot(df['time'], df['tunnel2'], label='Tunnel 2')
plt.plot(df['time'], df['long_term_ema'], label='Long-term EMA')
plt.legend(loc='upper left')
plt.title('Price Data and Indicators')
plt.xlabel('Time')
plt.ylabel('Price')
plt.tight_layout()
plt.show()
# # Check Support and Resistance Proximity
# Implement support and resistance proximity
def sma(data, period):
    sma_values = []
    for i in range(len(data)):
        if i < period or None in data[i - period + 1: i + 1]:
            sma_values.append(None)
        else:
            sma_values.append(sum(filter(None, data[i - period + 1: i + 1])) / period)
    return sma_values
def min_low(low_data, period):
    min_low_values = []
    for i in range(len(low_data)):
        if i < period:
            min_low_values.append(None)
        else:
            min_low_values.append(min(low_data[i - period + 1: i + 1]))
    return min_low_values
def max_high(high_data, period):
    max_high_values = []
    for i in range(len(high_data)):
        if i < period:
            max_high_values.append(None)
        else:
            max_high_values.append(max(high_data[i - period + 1: i + 1]))
    return max_high_values
def check_support_resistance_proximity(row):
    support_level = sma(min_low(df['low'], 18), 5)
    resistance_level = sma(max_high(df['high'], 18), 5)
    proximity_threshold = 0.01  # Adjust this value based on user input
    if support_level[-1] is not None:
        near_support = row['close'] <= support_level[-1] * (1 + proximity_threshold)
    else:
        near_support = False
    if resistance_level[-1] is not None:
        near_resistance = row['close'] >= resistance_level[-1] * (1 - proximity_threshold)
    else:
        near_resistance = False
    return near_support, near_resistance
print("Checking support and resistance proximity...")
df['near_support'], df['near_resistance'] = zip(*df.apply(check_support_resistance_proximity, axis=1))
print("Support and Resistance Proximity:")
print(df[['time', 'close', 'near_support', 'near_resistance']])
# # Implement Risk Management and Position Sizing
# User inputs
min_auto_tp_threshold_values = {
    'USD': 5,
    'EUR': 10,
    'JPY': 100,
    'GBP': 50,
    'CHF': 5,
    'AUD': 5,
    'default': 100
}
last_tp_limit_values = {
    'USD': 15,
    'EUR': 10,
    'JPY': 800,
    'GBP': 60,
    'CHF': 15,
    'AUD': 15,
    'default': 250
}
enable_second_strategy = True
min_gap_second_values = {
    'USD': 15,
    'EUR': 15,
    'JPY': 650,
    'GBP': 50,
    'CHF': 15,
    'AUD': 15,
    'default': 650
}
max_allow_into_zone = 0.25
# Risk management and position sizing
risk_percent = 0.02  # Adjust this value based on your risk tolerance
account_balance = mt5.account_info().balance
def calculate_position_size(price):
    risk_amount = account_balance * risk_percent
    position_size = risk_amount / (price * mt5.symbol_info(symbol).trade_tick_size)
    return position_size
# # Order Management and Position Execution
# Order management
def open_position(signal_type, price):
    if signal_type == "buy":
        lot_size = calculate_position_size(price)
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": lot_size,
            "type": mt5.ORDER_TYPE_BUY,
            "price": price,
            "magic": 12345,
            "comment": "Python Buy Order",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_IOC,
        }
        result = mt5.order_send(request)
        print(f"Buy Order Sent: {result}")
    elif signal_type == "sell":
        lot_size = calculate_position_size(price)
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": lot_size,
            "type": mt5.ORDER_TYPE_SELL,
            "price": price,
            "magic": 12345,
            "comment": "Python Sell Order",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_IOC,
        }
        result = mt5.order_send(request)
        print(f"Sell Order Sent: {result}")
def close_positions():
    positions = mt5.positions_get(symbol=symbol)
    for position in positions:
        if position.type == mt5.POSITION_TYPE_BUY:
            close_request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": position.volume,
                "type": mt5.ORDER_TYPE_SELL,
                "position": position.ticket,
                "price": mt5.symbol_info_tick(symbol).bid,
                "magic": 12345,
                "comment": "Python Close Buy Order",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_IOC,
                }
            result = mt5.order_send(close_request)
            print(f"Closed Buy Position: {result}")
        elif position.type == mt5.POSITION_TYPE_SELL:
            close_request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": position.volume,
                "type": mt5.ORDER_TYPE_BUY,
                "position": position.ticket,
                "price": mt5.symbol_info_tick(symbol).ask,
                "magic": 12345,
                "comment": "Python Close Sell Order",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_IOC,
              }
            result = mt5.order_send(close_request)
            print(f"Closed Sell Position: {result}")
# # Position Execution and Final Output
# Print the positions to take
def print_positions(df):
    buy_signals = df[df['buy_signal'] == True]
    sell_signals = df[df['sell_signal'] == True]
    print("Positions to take:")
    for index, row in buy_signals.iterrows():
        print(f"Buy {symbol} at {row['close']}")
        open_position("buy", row['close'])
    for index, row in sell_signals.iterrows():
        print(f"Sell {symbol} at {row['close']}")
        open_position("sell", row['close'])
print_positions(df)
close_positions()
# # Second Jupyter Notebook Script with Back Testing
# Importing required libraries
import numpy as np
import pandas as pd
import MetaTrader5 as mt5
import matplotlib.pyplot as plt
# Connecting to the MetaTrader5 terminal
if not mt5.initialize():
    print("Failed to initialize MetaTrader5")
    mt5.shutdown()
else:
    print("MetaTrader5 initialized successfully")
# Specifying the symbol and timeframe
symbol = "EURUSD"
timeframe = mt5.TIMEFRAME_H1  # 1-hour timeframe
# Retrieving historical price data
num_bars = 1000  # Number of bars to retrieve
rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, num_bars)
# Converting the data to a pandas DataFrame
df = pd.DataFrame(rates, columns=['time', 'open', 'high', 'low', 'close', 'tick_volume', 'spread', 'real_volume'])
df['time'] = pd.to_datetime(df['time'], unit='s')
# Printing the DataFrame
print("Historical Price Data:")
print(df.head())
# Implementing the Wavy Tunnel and other indicators
def ema(data, period):
    ema_values = [None] * (period - 1)  # Initialize with None for the first period - 1 values
    sma = sum(data[:period]) / period
    ema_values.append(sma)
    multiplier = 2 / (period + 1)
    for price in data[period:]:
        ema = (price - ema_values[-1]) * multiplier + ema_values[-1]
        ema_values.append(ema)
    return ema_values
# Wavy Tunnel
df['wavy_h'] = ema(df['high'], 34)
df['wavy_c'] = ema(df['close'], 34)
df['wavy_l'] = ema(df['low'], 34)
df['tunnel1'] = ema(df['close'], 144)
df['tunnel2'] = ema(df['close'], 169)
# Printing the Wavy Tunnel columns
print("Wavy Tunnel:")
print(df[['time', 'high', 'low', 'close', 'wavy_h', 'wavy_c', 'wavy_l', 'tunnel1', 'tunnel2']].head())
# Plotting the Wavy Tunnel
plt.figure(figsize=(12, 6))
plt.plot(df['time'], df['close'], label='Price')
plt.plot(df['time'], df['wavy_h'], label='Wavy High')
plt.plot(df['time'], df['wavy_c'], label='Wavy Close')
plt.plot(df['time'], df['wavy_l'], label='Wavy Low')
plt.plot(df['time'], df['tunnel1'], label='Tunnel 1')
plt.plot(df['time'], df['tunnel2'], label='Tunnel 2')
plt.xlabel('Time')
plt.ylabel('Price')
plt.title('Wavy Tunnel')
plt.legend()
plt.grid(True)
plt.show()
# # Inputs and Entry conditions
# Implementing user inputs
apply_threshold = True
threshold_values = {
    'USD': 2,
    'EUR': 2,
    'JPY': 300,
    'GBP': 6,
    'CHF': 2,
    'AUD': 2,
    'default': 100
}
# Liquidation level threshold
min_auto_tp_threshold_values = {
    'USD': 5,
    'EUR': 10,
    'JPY': 100,
    'GBP': 50,
    'CHF': 5,
    'AUD': 5,
    'default': 100
}
# Last take profit limit
last_tp_limit_values = {
    'USD': 15,
    'EUR': 10,
    'JPY': 800,
    'GBP': 60,
    'CHF': 15,
    'AUD': 15,
    'default': 250
}
peak_type = 21
enable_second_strategy = True
min_gap_second_values = {
    'USD': 15,
    'EUR': 15,
    'JPY': 650,
    'GBP': 50,
    'CHF': 15,
    'AUD': 15,
    'default': 650
}
max_allow_into_zone = 0.25
is_range = False
from_date = '2024-02-01'
to_date = '2024-03-16'
is_proximity = True
support_resistance_proximity = 0.01
# Implementing peak and dip detection
def detect_peaks_and_dips(df, peak_type):
    peaks = []
    dips = []
    for i in range(len(df)):
        if i < peak_type or i >= len(df) - peak_type:
            continue
        is_peak = True
        is_dip = True
        for j in range(peak_type):
            if df['high'][i] <= df['high'][i-j] or df['high'][i] <= df['high'][i+j]:
                is_peak = False
            if df['low'][i] >= df['low'][i-j] or df['low'][i] >= df['low'][i+j]:
                is_dip = False
        if is_peak:
            peaks.append(df['high'][i])
        if is_dip:
            dips.append(df['low'][i])
    return peaks, dips
peak_type = 21
peaks, dips = detect_peaks_and_dips(df, peak_type)
print("Peaks:")
print(peaks[:5])
print("Dips:")
print(dips[:5])
# Implementing liquidation levels
def find_last_peak_dip(peaks, dips, current_price, min_threshold):
    last_peak = np.nan
    last_dip = np.nan
    for peak in reversed(peaks):
        if peak > current_price + min_threshold:
            last_peak = peak
            break
    for dip in reversed(dips):
        if dip < current_price - min_threshold:
            last_dip = dip
            break
    return last_peak, last_dip
min_threshold = 100  # Adjust this value based on the user input
# Implementing entry conditions
def check_entry_conditions(row, peaks, dips):
    buy_condition = (
        row['close'] > max(row['wavy_c'], row['wavy_h'], row['wavy_l']) and
        min(row['wavy_c'], row['wavy_h'], row['wavy_l']) > max(row['tunnel1'], row['tunnel2']) and
        row['close'] in peaks  # Check if the current close price is a peak
    )
    sell_condition = (
        row['close'] < min(row['wavy_c'], row['wavy_h'], row['wavy_l']) and
        max(row['wavy_c'], row['wavy_h'], row['wavy_l']) < min(row['tunnel1'], row['tunnel2']) and
        row['close'] in dips  # Check if the current close price is a dip
    )
    if apply_threshold:
        threshold = threshold_values.get(symbol[:3], threshold_values['default']) * mt5.symbol_info(symbol).trade_tick_size
        buy_condition &= row['close'] > max(row['wavy_c'], row['wavy_h'], row['wavy_l']) + threshold
        sell_condition &= row['close'] < min(row['wavy_c'], row['wavy_h'], row['wavy_l']) - threshold
    return buy_condition, sell_condition
df['buy_signal'], df['sell_signal'] = zip(*df.apply(lambda x: check_entry_conditions(x, peaks, dips), axis=1))
print("Entry Signals:")
print(df[['time', 'close', 'buy_signal', 'sell_signal']].head())
# # Back Testing and Results
# Implementing support and resistance proximity
def sma(data, period):
    sma_values = []
    for i in range(len(data)):
        if i < period or None in data[i - period + 1: i + 1]:
            sma_values.append(None)
        else:
            sma_values.append(sum(filter(None, data[i - period + 1: i + 1])) / period)
    return sma_values
def min_low(low_data, period):
    min_low_values = []
    for i in range(len(low_data)):
        if i < period:
            min_low_values.append(None)
        else:
            min_low_values.append(min(low_data[i - period + 1: i + 1]))
    return min_low_values
def max_high(high_data, period):
    max_high_values = []
    for i in range(len(high_data)):
        if i < period:
            max_high_values.append(None)
        else:
            max_high_values.append(max(high_data[i - period + 1: i + 1]))
    return max_high_values
def check_support_resistance_proximity(row):
    support_level = sma(min_low(df['low'], 18), 5)
    resistance_level = sma(max_high(df['high'], 18), 5)
    proximity_threshold = 0.01  # Adjust this value based on user input
    if support_level[-1] is not None:
        near_support = row['close'] <= support_level[-1] * (1 + proximity_threshold)
    else:
        near_support = False
    if resistance_level[-1] is not None:
        near_resistance = row['close'] >= resistance_level[-1] * (1 - proximity_threshold)
    else:
        near_resistance = False
    return near_support, near_resistance
df['near_support'], df['near_resistance'] = zip(*df.apply(check_support_resistance_proximity, axis=1))
print("Support and Resistance Proximity:")
print(df[['time', 'close', 'near_support', 'near_resistance']].head())
# Implementing position management
def calculate_position_size(row):
    balance = mt5.account_info().balance
    risk_percent = 0.01  # Adjust this value based on user input
    position_size = (balance * risk_percent) / (row['close'] * mt5.symbol_info(symbol).trade_tick_size)
    return position_size
def open_position(row):
    if row['buy_signal'] and not row['near_resistance']:
        lot_size = calculate_position_size(row)
        last_peak, _ = find_last_peak_dip(peaks, dips, row['close'], min_threshold)
        stop_loss = last_peak - (row['close'] - last_peak) * 1.5  # Set stop-loss level based on last peak
        take_profit = row['close'] + (row['close'] - last_peak) * 2  # Set take-profit level based on last peak
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": lot_size,
            "type": mt5.ORDER_TYPE_BUY,
            "price": row['close'],
            "sl": stop_loss,  # Set stop-loss price
            "tp": take_profit,  # Set take-profit price
            "magic": 12345,
            "comment": "Python Buy Order",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_IOC,
        }
        result = mt5.order_send(request)
        print(f"Buy Order Sent: {result}")
    elif row['sell_signal'] and not row['near_support']:
        lot_size = calculate_position_size(row)
        _, last_dip = find_last_peak_dip(peaks, dips, row['close'], min_threshold)
        stop_loss = last_dip + (last_dip - row['close']) * 1.5  # Set stop-loss level based on last dip
        take_profit = row['close'] - (last_dip - row['close']) * 2  # Set take-profit level based on last dip
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": lot_size,
            "type": mt5.ORDER_TYPE_SELL,
            "price": row['close'],
            "sl": stop_loss,  # Set stop-loss price
            "tp": take_profit,  # Set take-profit price
            "magic": 12345,
            "comment": "Python Sell Order",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_IOC,
        }
        result = mt5.order_send(request)
        print(f"Sell Order Sent: {result}")
def close_positions():
    positions = mt5.positions_get(symbol=symbol)
    for position in positions:
        if position.type == mt5.POSITION_TYPE_BUY:
            close_request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": position.volume,
                "type": mt5.ORDER_TYPE_SELL,
                "position": position.ticket,
                "price": mt5.symbol_info_tick(symbol).bid,
                "magic": 12345,
                "comment": "Python Close Buy Order",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_IOC,
            }
            result = mt5.order_send(close_request)
            print(f"Closed Buy Position: {result}")
        elif position.type == mt5.POSITION_TYPE_SELL:
            close_request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": position.volume,
                "type": mt5.ORDER_TYPE_BUY,
                "position": position.ticket,
                "price": mt5.symbol_info_tick(symbol).ask,
                "magic": 12345,
                "comment": "Python Close Sell Order",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_IOC,
            }
            result = mt5.order_send(close_request)
            print(f"Closed Sell Position: {result}")
# Implementing the second strategy
def check_second_strategy_conditions(row):
    fully_crossed_above = (
        row['close'] > max(row['wavy_c'], row['wavy_h'], row['wavy_l']) and
        row['close'] < min(row['tunnel1'], row['tunnel2'])
    )
    fully_crossed_below = (
        row['close'] < min(row['wavy_c'], row['wavy_h'], row['wavy_l']) and
        row['close'] > max(row['tunnel1'], row['tunnel2'])
    )
    return fully_crossed_above, fully_crossed_below
df['second_buy_signal'], df['second_sell_signal'] = zip(*df.apply(check_second_strategy_conditions, axis=1))
# Implementing backtesting and visualization
initial_balance = 10000
balance = initial_balance
position = None
trades = []
for _, row in df.iterrows():
    if position is None:
        if row['buy_signal']:
            position = 'long'
            entry_price = row['close']
            entry_time = row['time']
            lot_size = calculate_position_size(row)
            balance -= lot_size * entry_price
            trades.append(('buy', entry_time, entry_price, lot_size))
            open_position(row)  # Open a buy position
        elif row['sell_signal']:
            position = 'short'
            entry_price = row['close']
            entry_time = row['time']
            lot_size = calculate_position_size(row)
            balance += lot_size * entry_price
            trades.append(('sell', entry_time, entry_price, lot_size))
            open_position(row)  # Open a sell position
    else:
        if position == 'long' and (row['sell_signal'] or row['close'] < min(row['wavy_c'], row['wavy_h'], row['wavy_l'])):
            exit_price = row['close']
            exit_time = row['time']
            balance += lot_size * exit_price
            trades.append(('sell', exit_time, exit_price, lot_size))
            close_positions()  # Close the buy position
            position = None
        elif position == 'short' and (row['buy_signal'] or row['close'] > max(row['wavy_c'], row['wavy_h'], row['wavy_l'])):
            exit_price = row['close']
            exit_time = row['time']
            balance -= lot_size * exit_price
            trades.append(('buy', exit_time, exit_price, lot_size))
            close_positions()  # Close the sell position
            position = None
final_balance = balance
profit = final_balance - initial_balance
print(f"Initial Balance: {initial_balance}")
print(f"Final Balance: {final_balance}")
print(f"Profit: {profit}")
# Plotting entry and exit signals
plt.figure(figsize=(12, 6))
plt.plot(df['time'], df['close'], label='Price')
buy_signals = df[df['buy_signal']]['close']
sell_signals = df[df['sell_signal']]['close']
plt.scatter(buy_signals.index, buy_signals, color='green', label='Buy Signal', marker='^')
plt.scatter(sell_signals.index, sell_signals, color='red', label='Sell Signal', marker='v')
for trade in trades:
    if trade[0] == 'buy':
        plt.axvline(x=trade[1], color='green', linestyle='--', alpha=0.7)
    elif trade[0] == 'sell':
        plt.axvline(x=trade[1], color='red', linestyle='--', alpha=0.7)
plt.xlabel('Time')
plt.ylabel('Price')
plt.title('Entry and Exit Signals')
plt.legend()
plt.grid(True)
plt.show()
# Disconnecting from the MetaTrader5 terminal
mt5.shutdown()
print("MetaTrader5 disconnected")

</document_content>
</document>

<document index="8">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\jupyter_notebooks\script.py</source>
<document_content>
import os
import json

def extract_code_and_markdown(ipynb_file, output_file):
    script_dir = os.path.dirname(os.path.abspath(__file__))
    ipynb_path = os.path.join(script_dir, ipynb_file)
    with open(ipynb_path, 'r', encoding='utf-8') as f:
        notebook = json.load(f)
    
    with open(output_file, 'w', encoding='utf-8') as f:
        for cell in notebook['cells']:
            if cell['cell_type'] == 'markdown':
                # Write markdown content as comments
                f.write("# " + ''.join(cell['source']) + '\n\n')
            elif cell['cell_type'] == 'code':
                # Write code cells
                f.write('\n'.join(cell['source']) + '\n\n')

if __name__ == "__main__":
    ipynb_file = "full_strategy_conversion.ipynb"
    output_file = "output_script.py"
    extract_code_and_markdown(ipynb_file, output_file)

</document_content>
</document>

<document index="9">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\metatrader\connection.py</source>
<document_content>
import MetaTrader5 as mt5
# import MetaTrader4 as mt4
import win32com.client
import time

def connect(login, password, server, path, mt_version):
    if mt_version == 5:
        if not mt5.initialize(path=path, login=login, password=password, server=server):
            print("initialize() failed for MT5, error code =", mt5.last_error())
            return False
        return True
    # elif mt_version == 4:
    #     try:
    #         mt4_client = mt4.MT4()
    #         mt4_client.Connect(server, login, password, "")
    #         return True
    #     except Exception as e:
    #         print("initialize() failed for MT4, error =", e)
    #         return False
    else:
        raise ValueError("Invalid MetaTrader version. Please specify 4 or 5.")

def disconnect(mt_version):
    if mt_version == 5:
        mt5.shutdown()
    # elif mt_version == 4:
    #     try:
    #         mt4_client = mt4.MT4()
    #         mt4_client.Disconnect()
    #     except Exception as e:
    #         print("disconnect() failed for MT4, error =", e)

def check_connection(mt_version):
    if mt_version == 5:
        return mt5.terminal_info() is not None
    # elif mt_version == 4:
    #     try:
    #         mt4_client = mt4.MT4()
    #         return mt4_client.IsConnected()
    #     except Exception as e:
    #         print("check_connection() failed for MT4, error =", e)
    #         return False
    # else:
    #     raise ValueError("Invalid MetaTrader version. Please specify 4 or 5.")

def initialize_mt5(mt5_path):
    # Initialize MetaTrader 5
    if not mt5.initialize(path=mt5_path):
        print("Failed to initialize MetaTrader 5 terminal.")
        mt5.shutdown()
        return False
    else:
        print("MetaTrader 5 terminal initialized successfully.")
        return True

def shutdown_mt5():
    # Shutdown MetaTrader 5
    mt5.shutdown()
    print("MetaTrader 5 connection gracefully shut down.")

</document_content>
</document>

<document index="10">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\metatrader\data_retrieval.py</source>
<document_content>
import MetaTrader5 as mt5
import pandas as pd
import requests_cache
from datetime import datetime, timedelta
from requests_cache import CachedSession
from utils.error_handling import handle_error


def initialize_mt5():
    if not mt5.initialize():
        print("Failed to initialize MetaTrader5")
        mt5.shutdown()
        return False
    return True

def shutdown_mt5():
    mt5.shutdown()

start_time = datetime.now() - timedelta(days=30)  # Example: 30 days ago
end_time = datetime.now()  # Current time

def get_historical_data(symbol, timeframe, start_time, end_time):
    try:
        # Retrieve data from MT5
        rates = mt5.copy_rates_range(symbol, timeframe, start_time, end_time)
        data = pd.DataFrame(rates, columns=['time', 'open', 'high', 'low', 'close', 'tick_volume', 'spread', 'real_volume'])
        data['time'] = pd.to_datetime(data['time'], unit='s')

        return data
    except Exception as e:
        handle_error(e, f"Failed to retrieve historical data for {symbol}")
        return None
#requests_cache.install_cache('historical_data_cache', backend='sqlite', expire_after=3600)

# def get_historical_data(symbol, timeframe, start_time, end_time):
#     try:
#         # Create a cached session
#         session = CachedSession('historical_data_cache', backend='sqlite', expire_after=3600)

#         # Check if data is available in cache
#         cache_key = f"{symbol}_{timeframe}_{start_time}_{end_time}"
        
#         def retrieve_data():
#             # Retrieve data from MT5
#             rates = mt5.copy_rates_range(symbol, timeframe, start_time, end_time)
#             data = pd.DataFrame(rates, columns=['time', 'open', 'high', 'low', 'close', 'tick_volume', 'spread', 'real_volume'])
#             data['time'] = pd.to_datetime(data['time'], unit='s')
#             return data

#         data = session.cache.get_or_set(cache_key, retrieve_data)

#         return data
#     except Exception as e:
#         handle_error(e, f"Failed to retrieve historical data for {symbol}")
#         return None
# def get_historical_data(symbol, timeframe, start_time, end_time):
#     try:
#         # Create a cached session
#         session = CachedSession('historical_data_cache', backend='sqlite', expire_after=3600)

#         # Check if data is available in cache
#         cache_key = f"{symbol}_{timeframe}_{start_time}_{end_time}"
#         cached_data = session.cache.get(cache_key)
#         if cached_data:
#             return pd.read_json(cached_data)

#         # Retrieve data from MT5
#         rates = mt5.copy_rates_range(symbol, timeframe, start_time, end_time)
#         data = pd.DataFrame(rates, columns=['time', 'open', 'high', 'low', 'close', 'tick_volume', 'spread', 'real_volume'])
#         data['time'] = pd.to_datetime(data['time'], unit='s')

#         # Store data in cache
#         session.cache.set(cache_key, data.to_json())

#         return data
#     except Exception as e:
#         handle_error(e, f"Failed to retrieve historical data for {symbol}")
#         return None
    
def retrieve_historical_data(symbol, start_date, end_date, timeframe):
    rates = mt5.copy_rates_range(symbol, timeframe, start_date, end_date)
    data = pd.DataFrame(rates, columns=['time', 'open', 'high', 'low', 'close', 'tick_volume', 'spread', 'real_volume'])
    data['time'] = pd.to_datetime(data['time'], unit='s')
    return data

def get_current_price(symbol):
    prices = mt5.symbol_info_tick(symbol)
    if prices:
        return prices.last
    else:
        print(f"Failed to retrieve current price for {symbol}")
        return None

def get_account_info():
    account_info = mt5.account_info()
    if account_info:
        return account_info._asdict()
    else:
        print("Failed to retrieve account information")
        return None

def get_available_symbols():
    symbols = mt5.symbols_get()
    if symbols:
        return [symbol.name for symbol in symbols]
    else:
        print("Failed to retrieve available symbols")
        return None

def get_symbol_info(symbol):
    symbol_info = mt5.symbol_info(symbol)
    if symbol_info:
        return symbol_info._asdict()
    else:
        print(f"Failed to retrieve information for {symbol}")
        return None

def get_positions():
    positions = mt5.positions_get()
    if positions:
        positions_data = []
        for position in positions:
            position_data = position._asdict()
            positions_data.append(position_data)
        return positions_data
    else:
        print("No open positions found")
        return None

def get_orders():
    orders = mt5.orders_get()
    if orders:
        orders_data = []
        for order in orders:
            order_data = order._asdict()
            orders_data.append(order_data)
        return orders_data
    else:
        print("No pending orders found")
        return None

if __name__ == '__main__':
    if initialize_mt5():
        symbol = "EURUSD"
        timeframe = mt5.TIMEFRAME_H1
        start_time = datetime(2023, 1, 1)
        end_time = datetime.now()

        historical_data = get_historical_data(symbol, timeframe, start_time, end_time)
        if historical_data is not None:
            print(f"Historical data for {symbol}:")
            print(historical_data.head())

        current_price = get_current_price(symbol)
        if current_price is not None:
            print(f"Current price for {symbol}: {current_price}")

        account_info = get_account_info()
        if account_info is not None:
            print("Account information:")
            print(account_info)

        available_symbols = get_available_symbols()
        if available_symbols is not None:
            print("Available symbols:")
            print(available_symbols)

        symbol_info = get_symbol_info(symbol)
        if symbol_info is not None:
            print(f"Symbol information for {symbol}:")
            print(symbol_info)

        positions = get_positions()
        if positions is not None:
            print("Open positions:")
            print(positions)

        orders = get_orders()
        if orders is not None:
            print("Pending orders:")
            print(orders)

        shutdown_mt5()
</document_content>
</document>

<document index="11">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\metatrader\indicators.py</source>
<document_content>
import numpy as np

def calculate_ema(prices, period):
    return np.convolve(prices, np.exp(-np.linspace(-1., 0., period)), mode='valid') / np.sum(np.exp(-np.linspace(-1., 0., period)))


</document_content>
</document>

<document index="12">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\metatrader\trade_management.py</source>
<document_content>
import MetaTrader5 as mt5

def place_order(symbol, order_type, volume, price=None, sl=None, tp=None):
    order = mt5.ORDER_TYPE_BUY if order_type == 'buy' else mt5.ORDER_TYPE_SELL
    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": volume,
        "type": order,
        "price": mt5.symbol_info_tick(symbol).ask if order_type == 'buy' else mt5.symbol_info_tick(symbol).bid,
        "sl": sl,
        "tp": tp,
        "deviation": 10,
        "magic": 234000,
        "comment": "python script order",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_IOC,
    }
    result = mt5.order_send(request)
    return result.comment if result else 'Order failed'

def close_position(ticket):
    position = mt5.positions_get(ticket=ticket)
    if position:
        result = mt5.Close(ticket)
        return result.comment if result else 'Close failed'
    return 'Position not found'

def modify_order(ticket, sl=None, tp=None):
    result = mt5.order_check(ticket)
    if result and result.type in [mt5.ORDER_TYPE_BUY, mt5.ORDER_TYPE_SELL]:
        request = {
            "action": mt5.TRADE_ACTION_SLTP,
            "ticket": ticket,
            "sl": sl,
            "tp": tp
        }
        result = mt5.order_send(request)
        return result.comment if result else 'Modify failed'
    return 'Order not found'

</document_content>
</document>

<document index="13">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\metatrader\__init__.py</source>
<document_content>
from .data_retrieval import get_historical_data
</document_content>
</document>

<document index="14">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\strategy\trade_logic.py</source>
<document_content>
from utils.error_handling import handle_error
from tunnel_strategy import execute_trade, manage_position

def calculate_position_size(account_balance, risk_per_trade, stop_loss_pips, pip_value):
    risk_amount = account_balance * risk_per_trade
    position_size = risk_amount / (stop_loss_pips * pip_value)
    return position_size

def entry_long(symbol, lot_size, price, sl, tp, deviation, magic, comment):
    trade_request = {
        'action': 'BUY',
        'symbol': symbol,
        'volume': lot_size,
        'price': price,
        'sl': sl,
        'tp': tp,
        'deviation': deviation,
        'magic': magic,
        'comment': comment,
        'type': 'ORDER_TYPE_BUY',
        'type_filling': 'ORDER_FILLING_FOK',
        'type_time': 'ORDER_TIME_GTC'
    }
    return execute_trade(trade_request)

def entry_short(symbol, lot_size, price, sl, tp, deviation, magic, comment):
    trade_request = {
        'action': 'SELL',
        'symbol': symbol,
        'volume': lot_size,
        'price': price,
        'sl': sl,
        'tp': tp,
        'deviation': deviation,
        'magic': magic,
        'comment': comment,
        'type': 'ORDER_TYPE_SELL',
        'type_filling': 'ORDER_FILLING_FOK',
        'type_time': 'ORDER_TIME_GTC'
    }
    return execute_trade(trade_request)

def exit_trade(position_ticket):
    try:
        close_request = {
            'action': 'CLOSE',
            'position': position_ticket,
            'type': 'ORDER_TYPE_CLOSE',
            'type_filling': 'ORDER_FILLING_FOK',
            'type_time': 'ORDER_TIME_GTC'
        }
        return execute_trade(close_request)
    except Exception as e:
        handle_error(e, "Failed to close the trade")
        return False
</document_content>
</document>

<document index="15">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\strategy\tunnel_strategy.py</source>
<document_content>
import numpy as np
from metatrader.data_retrieval import get_historical_data
from utils.error_handling import handle_error
from metatrader.indicators import calculate_ema
from metatrader.trade_management import place_order, close_position, modify_order
import pandas as pd
import MetaTrader5 as mt5

def execute_trade(trade_request):
    try:
        result = place_order(
            trade_request['symbol'],
            trade_request['action'].lower(),
            trade_request['volume'],
            trade_request['price'],
            trade_request['sl'],
            trade_request['tp']
        )
        if result == 'Order failed':
            raise Exception("Failed to execute trade")
        return result
    except Exception as e:
        handle_error(e, "Failed to execute trade")
        return None

def manage_position(symbol, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day):
    try:
        positions = mt5.positions_get(symbol=symbol)
        if positions:
            for position in positions:
                if position.profit >= min_take_profit:
                    close_position(position.ticket)
                elif position.profit <= -max_loss_per_day:
                    close_position(position.ticket)
                else:
                    current_equity = mt5.account_info().equity
                    if current_equity <= starting_equity * 0.9:  # Close position if equity drops by 10%
                        close_position(position.ticket)
                    elif mt5.positions_total() >= max_trades_per_day:
                        close_position(position.ticket)
    except Exception as e:
        handle_error(e, "Failed to manage position")

def calculate_tunnel_bounds(data, period, deviation_factor):
    ema = calculate_ema(data['close'], period)
    volatility = np.std(data['close'])
    deviation = deviation_factor * volatility
    upper_bound = ema + deviation
    lower_bound = ema - deviation
    return upper_bound, lower_bound

def calculate_position_size(self, balance, risk_percent):
        # Calculate position size based on balance and risk percentage
        risk_amount = balance * risk_percent
        position_size = risk_amount / (self.stop_loss * self.point_value)
        return position_size

def generate_trade_signal(data, period, deviation_factor):
    upper_bound, lower_bound = calculate_tunnel_bounds(data, period, deviation_factor)
    if data['close'].iloc[-1] > upper_bound[-1]:
        return 'BUY'
    elif data['close'].iloc[-1] < lower_bound[-1]:
        return 'SELL'
    else:
        return None

def adjust_deviation_factor(market_conditions):
    if market_conditions == 'volatile':
        return 2.5
    else:
        return 2.0

def run_strategy(symbols, mt5_init, timeframe, lot_size, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day):
    try:
        for symbol in symbols:
            
            start_time = pd.Timestamp.now() - pd.Timedelta(days=30)  # Example: 30 days ago
            end_time = pd.Timestamp.now()  # Current time
            data = get_historical_data(symbol, timeframe, start_time, end_time)
            if data is None:
                raise Exception(f"Failed to retrieve historical data for {symbol}")

            period = 20
            market_conditions = 'volatile'  # Placeholder for determining market conditions
            deviation_factor = adjust_deviation_factor(market_conditions)

            signal = generate_trade_signal(data, period, deviation_factor)

            if signal == 'BUY':
                trade_request = {
                    'action': 'BUY',
                    'symbol': symbol,
                    'volume': lot_size,
                    'price': data['close'].iloc[-1],
                    'sl': data['close'].iloc[-1] - (1.5 * np.std(data['close'])),
                    'tp': data['close'].iloc[-1] + (2 * np.std(data['close'])),
                    'deviation': 10,
                    'magic': 12345,
                    'comment': 'Tunnel Strategy',
                    'type': 'ORDER_TYPE_BUY',
                    'type_filling': 'ORDER_FILLING_FOK',
                    'type_time': 'ORDER_TIME_GTC'
                }
                execute_trade(trade_request)
            elif signal == 'SELL':
                trade_request = {
                    'action': 'SELL',
                    'symbol': symbol,
                    'volume': lot_size,
                    'price': data['close'].iloc[-1],
                    'sl': data['close'].iloc[-1] + (1.5 * np.std(data['close'])),
                    'tp': data['close'].iloc[-1] - (2 * np.std(data['close'])),
                    'deviation': 10,
                    'magic': 12345,
                    'comment': 'Tunnel Strategy',
                    'type': 'ORDER_TYPE_SELL',
                    'type_filling': 'ORDER_FILLING_FOK',
                    'type_time': 'ORDER_TIME_GTC'
                }
                execute_trade(trade_request)

            manage_position(symbol, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day)

    except Exception as e:
        handle_error(e, "Failed to run the strategy")
</document_content>
</document>

<document index="16">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\strategy\__init__.py</source>
<document_content>
from .tunnel_strategy import run_strategy
</document_content>
</document>

<document index="17">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\tests\test_connection.py</source>
<document_content>
import unittest
from unittest.mock import patch
from metatrader.connection import initialize_mt5, shutdown_mt5

class TestConnection(unittest.TestCase):
    @patch('MetaTrader5.initialize', return_value=True)
    def test_initialize_mt5_success(self, mock_initialize):
        self.assertTrue(initialize_mt5())

    @patch('MetaTrader5.initialize', return_value=False)
    def test_initialize_mt5_failure(self, mock_initialize):
        self.assertFalse(initialize_mt5())

    @patch('MetaTrader5.shutdown')
    def test_shutdown_mt5(self, mock_shutdown):
        shutdown_mt5()
        mock_shutdown.assert_called_once()

if __name__ == '__main__':
    unittest.main()
</document_content>
</document>

<document index="18">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\tests\test_data_retrieval.py</source>
<document_content>
import unittest
from unittest.mock import patch
from datetime import datetime
from metatrader.data_retrieval import get_historical_data

class TestDataRetrieval(unittest.TestCase):
    @patch('MetaTrader5.copy_rates_range', return_value=[])
    def test_get_historical_data_success(self, mock_copy_rates_range):
        symbol = "EURUSD"
        timeframe = 1
        start_time = datetime(2023, 1, 1)
        end_time = datetime.now()
        data = get_historical_data(symbol, timeframe, start_time, end_time)
        self.assertIsNotNone(data)

    @patch('MetaTrader5.copy_rates_range', return_value=None)
    def test_get_historical_data_failure(self, mock_copy_rates_range):
        symbol = "EURUSD"
        timeframe = 1
        start_time = datetime(2023, 1, 1)
        end_time = datetime.now()
        data = get_historical_data(symbol, timeframe, start_time, end_time)
        self.assertIsNone(data)

if __name__ == '__main__':
    unittest.main()
</document_content>
</document>

<document index="19">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\tests\test_indicators.py</source>
<document_content>
import unittest
from metatrader.indicators import calculate_ema

class TestIndicators(unittest.TestCase):
    def test_calculate_ema(self):
        data = [100, 200, 300, 400, 500]
        period = 3
        expected_ema = [100.0, 150.0, 233.33333333333334, 344.44444444444446, 455.55555555555554]
        self.assertEqual(calculate_ema(data, period), expected_ema)

if __name__ == '__main__':
    unittest.main()
    unittest.main()
</document_content>
</document>

<document index="20">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\tests\test_strategy.py</source>
<document_content>
import unittest
from unittest.mock import patch
from strategy.tunnel_strategy import run_strategy

class TestStrategy(unittest.TestCase):
    @patch('metatrader.data_retrieval.get_historical_data', return_value=None)
    def test_run_strategy_failure(self, mock_get_historical_data):
        symbols = ["EURUSD"]
        mt5_init = True
        timeframe = 1
        lot_size = 0.1
        min_take_profit = 100
        max_loss_per_day = 1000
        starting_equity = 10000
        max_traders_per_day = 5
        with self.assertRaises(Exception):
            run_strategy(symbols, mt5_init, timeframe, lot_size, min_take_profit, max_loss_per_day, starting_equity, max_traders_per_day)

if __name__ == '__main__':
    unittest.main()
</document_content>
</document>

<document index="21">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\tests\test_trade_management.py</source>
<document_content>
import unittest
from unittest.mock import patch
from metatrader.trade_management import place_order, close_position, modify_order

class TestTradeManagement(unittest.TestCase):
    @patch('MetaTrader5.order_send', return_value={'retcode': 10009})  # 10009: SUCCESS
    def test_place_order_success(self, mock_order_send):
        symbol = "EURUSD"
        order_type = "buy"
        volume = 0.1
        price = 1.2345
        sl = 1.2300
        tp = 1.2400
        result = place_order(symbol, order_type, volume, price, sl, tp)
        self.assertEqual(result, "python script order")

    @patch('MetaTrader5.order_send', return_value={'retcode': 10004})  # 10004: ERROR
    def test_place_order_failure(self, mock_order_send):
        symbol = "EURUSD"
        order_type = "buy"
        volume = 0.1
        price = 1.2345
        sl = 1.2300
        tp = 1.2400
        result = place_order(symbol, order_type, volume, price, sl, tp)
        self.assertEqual(result, "Order failed")

    @patch('MetaTrader5.positions_get', return_value=[{"ticket": 12345}])
    @patch('MetaTrader5.Close', return_value={"comment": "Close successful"})
    def test_close_position_success(self, mock_close, mock_positions_get):
        ticket = 12345
        result = close_position(ticket)
        self.assertEqual(result, "Close successful")

    @patch('MetaTrader5.positions_get', return_value=[])
    def test_close_position_failure(self, mock_positions_get):
        ticket = 12345
        result = close_position(ticket)
        self.assertEqual(result, "Position not found")

    @patch('MetaTrader5.order_check', return_value={"type": 0})  # 0: BUY
    @patch('MetaTrader5.order_send', return_value={"comment": "Modify successful"})
    def test_modify_order_success(self, mock_order_send, mock_order_check):
        ticket = 12345
        sl = 1.2300
        tp = 1.2400
        result = modify_order(ticket, sl, tp)
        self.assertEqual(result, "Modify successful")

    @patch('MetaTrader5.order_check', return_value=None)
    def test_modify_order_failure(self, mock_order_check):
        ticket = 12345
        sl = 1.2300
        tp = 1.2400
        result = modify_order(ticket, sl, tp)
        self.assertEqual(result, "Order not found")

if __name__ == '__main__':
    unittest.main()
</document_content>
</document>

<document index="22">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\tests\__init__.py</source>
<document_content>

</document_content>
</document>

<document index="23">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\utils\data_validation.py</source>
<document_content>
from typing import Any
from pydantic import BaseModel, ValidationError
from .logger import setup_logging
from .error_handling import handle_error

setup_logging()

class TradeRequestSchema(BaseModel):
    action: str
    symbol: str
    volume: float
    price: float
    sl: float
    tp: float
    deviation: int
    magic: int
    comment: str
    type: str
    type_filling: str
    type_time: str

class CloseRequestSchema(BaseModel):
    action: str
    position: int
    type: str
    type_filling: str
    type_time: str

def validate_data(data: Any, schema: dict) -> bool:
    try:
        if schema == TradeRequestSchema.schema():
            TradeRequestSchema(**data)
        elif schema == CloseRequestSchema.schema():
            CloseRequestSchema(**data)
        else:
            raise ValueError("Invalid schema provided")
        return True
    except ValidationError as e:
        handle_error(e, "Data validation failed")
        return False

def sanitize_data(data: Any) -> Any:
    try:
        if isinstance(data, dict):
            sanitized_data = {}
            for key, value in data.items():
                sanitized_data[key.strip()] = sanitize_data(value)
            return sanitized_data
        elif isinstance(data, list):
            return [sanitize_data(item) for item in data]
        elif isinstance(data, str):
            return data.strip()
        else:
            return data
    except Exception as e:
        handle_error(e, "Data sanitization failed")
        return None
    
def validate_trade_request(trade_request):
    required_fields = ['action', 'symbol', 'volume', 'price', 'sl', 'tp', 'deviation', 'magic', 'comment', 'type', 'type_filling', 'type_time']
    for field in required_fields:
        if field not in trade_request:
            raise ValueError(f"Missing required field: {field}")

    if trade_request['action'] not in ['BUY', 'SELL']:
        raise ValueError("Invalid trade action. Must be 'BUY' or 'SELL'")

    if trade_request['type'] not in ['ORDER_TYPE_BUY', 'ORDER_TYPE_SELL']:
        raise ValueError("Invalid order type. Must be 'ORDER_TYPE_BUY' or 'ORDER_TYPE_SELL'")

    if trade_request['type_filling'] != 'ORDER_FILLING_FOK':
        raise ValueError("Invalid order filling type. Must be 'ORDER_FILLING_FOK'")

    if trade_request['type_time'] != 'ORDER_TIME_GTC':
        raise ValueError("Invalid order time type. Must be 'ORDER_TIME_GTC'")

def validate_close_request(close_request):
    required_fields = ['action', 'position', 'type', 'type_filling', 'type_time']
    for field in required_fields:
        if field not in close_request:
            raise ValueError(f"Missing required field: {field}")

    if close_request['action'] != 'CLOSE':
        raise ValueError("Invalid close action. Must be 'CLOSE'")

    if close_request['type'] != 'ORDER_TYPE_CLOSE':
        raise ValueError("Invalid order type. Must be 'ORDER_TYPE_CLOSE'")

    if close_request['type_filling'] != 'ORDER_FILLING_FOK':
        raise ValueError("Invalid order filling type. Must be 'ORDER_FILLING_FOK'")

    if close_request['type_time'] != 'ORDER_TIME_GTC':
        raise ValueError("Invalid order time type. Must be 'ORDER_TIME_GTC'")
</document_content>
</document>

<document index="24">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\utils\error_handling.py</source>
<document_content>
import logging

def setup_logging():
    logging.basicConfig(
        level=logging.ERROR,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler('error.log')
        ]
    )

setup_logging()

def handle_error(error, message):
    logging.error(f"{message}: {str(error)}")

def critical_error(error, message):
    logging.critical(f"{message}: {str(error)}")
    raise SystemExit(1)

def warn_error(error, message):
    logging.warning(f"{message}: {str(error)}")
</document_content>
</document>

<document index="25">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\utils\logger.py</source>
<document_content>
import logging
import os
from logging.handlers import RotatingFileHandler

def setup_logging(log_level=logging.INFO, log_file="app.log", max_size=10485760, backup_count=10):
    """
    Set up logging configuration.
    """
    log_formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")

    file_handler = RotatingFileHandler(log_file, maxBytes=max_size, backupCount=backup_count)
    file_handler.setFormatter(log_formatter)

    console_handler = logging.StreamHandler()
    console_handler.setFormatter(log_formatter)

    logging.basicConfig(level=log_level, handlers=[file_handler, console_handler])
</document_content>
</document>

<document index="26">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\utils\plotting.py</source>
<document_content>
import matplotlib.pyplot as plt

def plot_backtest_results(data, trades):
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

    # Plot price data
    ax1.plot(data['time'], data['close'], label='Price')
    ax1.set_ylabel('Price')
    ax1.set_title('Backtest Results')
    ax1.grid(True)

    # Plot trades
    for trade in trades:
        entry_time = trade['entry_time']
        entry_price = trade['entry_price']
        exit_time = trade.get('exit_time')
        exit_price = trade.get('exit_price')

        if exit_time is None:
            ax1.plot(entry_time, entry_price, 'g^', markersize=8, label='Entry')
        else:
            ax1.plot(entry_time, entry_price, 'g^', markersize=8)
            ax1.plot(exit_time, exit_price, 'rv', markersize=8)
            ax1.plot([entry_time, exit_time], [entry_price, exit_price], 'k--')

    ax1.legend()

    # Plot account balance
    balance = [trade['balance'] for trade in trades]
    ax2.plot(data['time'], balance, label='Account Balance')
    ax2.set_ylabel('Balance')
    ax2.set_title('Account Balance')
    ax2.grid(True)
    ax2.legend()

    plt.tight_layout()
    plt.show()
</document_content>
</document>

<document index="27">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\utils\types.py</source>
<document_content>
from typing import NewType

TradeAction = NewType('TradeAction', str)
OrderType = NewType('OrderType', str)
OrderFilling = NewType('OrderFilling', str)
OrderTime = NewType('OrderTime', str)
# Define custom types
Symbol = NewType("Symbol", str)
Timeframe = NewType("Timeframe", str)
LotSize = NewType("LotSize", float)
</document_content>
</document>

<document index="28">
<source>C:\Users\16198\Desktop\automation\upwork\wavy\wavy_tunnel_bot\utils\__init__.py</source>
<document_content>
from .data_validation import validate_data, sanitize_data, validate_trade_request, validate_close_request
from .logger import setup_logging
from .types import TradeAction, OrderType, OrderFilling, OrderTime, Symbol, Timeframe, LotSize
</document_content>
</document>

</documents>