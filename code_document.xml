<documents>
<document index="1">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\config.py</source>
<document_content>
import os
from dotenv import load_dotenv
from utils.error_handling import handle_error, critical_error
import logging

script_dir = os.path.dirname(os.path.abspath(__file__))
project_dir = os.path.dirname(script_dir)
dotenv_path = os.path.join(project_dir, '.env')

def reload_env():
    load_dotenv(dotenv_path, override=True)

reload_env()

class Config:
    MT5_LOGIN = os.getenv("MT5_LOGIN")
    if not MT5_LOGIN:
        raise ValueError("MT5_LOGIN environment variable is not set.")

    MT5_PASSWORD = os.getenv("MT5_PASSWORD")
    if not MT5_PASSWORD:
        raise ValueError("MT5_PASSWORD environment variable is not set.")

    MT5_SERVER = os.getenv("MT5_SERVER")
    if not MT5_SERVER:
        raise ValueError("MT5_SERVER environment variable is not set.")

    MT5_PATH = os.getenv("MT5_PATH")
    if not MT5_PATH:
        raise ValueError("MT5_PATH environment variable is not set.")

    MT5_TIMEFRAME = os.getenv("MT5_TIMEFRAME")
    if MT5_TIMEFRAME not in ["M1", "M5", "M15", "M30", "H1", "H4", "D1"]:
        raise ValueError(f"Invalid MT5_TIMEFRAME value: {MT5_TIMEFRAME}. Expected values: M1, M5, M15, M30, H1, H4, D1.")

    SYMBOLS = os.getenv("SYMBOLS")
    if SYMBOLS:
        SYMBOLS = SYMBOLS.split(",")
    else:
        raise ValueError("SYMBOLS environment variable is not set.")

    TELEGRAM_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    TELEGRAM_IDS = os.getenv("TELEGRAM_IDS")
    if TELEGRAM_TOKEN and TELEGRAM_IDS:
        TELEGRAM_IDS = TELEGRAM_IDS.split(",")
    else:
        TELEGRAM_TOKEN = None
        TELEGRAM_IDS = None

    try:
        MIN_TP_PROFIT = float(os.getenv("MIN_TP_PROFIT", 50.0))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid MIN_TP_PROFIT value: {os.getenv('MIN_TP_PROFIT')}. Expected a numeric value.")

    try:
        MAX_LOSS_PER_DAY = float(os.getenv("MAX_LOSS_PER_DAY", 1000.0))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid MAX_LOSS_PER_DAY value: {os.getenv('MAX_LOSS_PER_DAY')}. Expected a numeric value.")

    try:
        STARTING_EQUITY = float(os.getenv("STARTING_EQUITY", 10000.0))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid STARTING_EQUITY value: {os.getenv('STARTING_EQUITY')}. Expected a numeric value.")

    try:
        LIMIT_NO_OF_TRADES = int(os.getenv("LIMIT_NO_OF_TRADES", 5))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid LIMIT_NO_OF_TRADES value: {os.getenv('LIMIT_NO_OF_TRADES')}. Expected an integer value.")

    try:
        RISK_PER_TRADE = float(os.getenv("RISK_PER_TRADE", 0.01))
    except ValueError:
        raise ValueError(f"Invalid RISK_PER_TRADE value: {os.getenv('RISK_PER_TRADE')}. Expected a numeric value.")

    if not 0 < RISK_PER_TRADE <= 1:
        raise ValueError(f"RISK_PER_TRADE value must be between 0 and 1. Current value: {RISK_PER_TRADE}")

    try:
        PIP_VALUE = float(os.getenv("PIP_VALUE", 1))
    except ValueError:
        raise ValueError(f"Invalid PIP_VALUE value: {os.getenv('PIP_VALUE')}. Expected a numeric value.")

    @classmethod
    def validate(cls):
        try:
            required_vars = [
                'MT5_LOGIN', 'MT5_PASSWORD', 'MT5_SERVER', 'MT5_PATH',
                'MT5_TIMEFRAME', 'SYMBOLS'
            ]
            for var in required_vars:
                if not getattr(cls, var, None):
                    raise ValueError(f"Missing required environment variable: {var}")

            numeric_vars = ['MIN_TP_PROFIT', 'MAX_LOSS_PER_DAY', 'STARTING_EQUITY', 'RISK_PER_TRADE', 'PIP_VALUE']
            for var in numeric_vars:
                if not isinstance(getattr(cls, var, None), (int, float)):
                    raise ValueError(f"Invalid value for {var}. Expected a numeric value.")

            if not isinstance(cls.LIMIT_NO_OF_TRADES, int):
                raise ValueError(f"Invalid value for LIMIT_NO_OF_TRADES. Expected an integer value.")

        except ValueError as e:
            handle_error(e, "Configuration validation failed")
            critical_error(e, "Invalid configuration settings")


    @classmethod
    def log_config(cls):
        for attr, value in cls.__dict__.items():
            if not callable(value) and not attr.startswith("__") and not isinstance(value, classmethod):
                logging.info(f"{attr}: {value}")

try:
    Config.validate()
except Exception as e:
    handle_error(e, "Error occurred during configuration validation")
    raise

</document_content>
</document>

<document index="2">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\main.py</source>
<document_content>
import MetaTrader5 as mt5
import pandas as pd
from datetime import datetime
from config import Config
from metatrader.connection import initialize_mt5, shutdown_mt5
from metatrader.data_retrieval import get_historical_data
from strategy.tunnel_strategy import run_strategy, calculate_ema, detect_peaks_and_dips, check_entry_conditions
from backtesting.backtest import run_backtest
from utils.logger import setup_logging
from utils.error_handling import handle_error
import logging
import argparse
from ui import run_ui
import os

def clear_log_file():
    with open("app.log", "w"):
        pass

def run_backtest_func():
    try:
        # Initialize MetaTrader5
        logging.info("Initializing MetaTrader5...")
        if not initialize_mt5(Config.MT5_PATH):
            raise Exception("Failed to initialize MetaTrader5")
        logging.info("MetaTrader5 initialized successfully.")

        for symbol in Config.SYMBOLS:
            logging.info("Running backtest...")
            start_date = datetime(2024, 6, 12)
            end_date = datetime.now()
            initial_balance = 10000
            risk_percent = Config.RISK_PER_TRADE
            stop_loss_pips = 20  # Example value for stop loss in pips
            pip_value = Config.PIP_VALUE

            backtest_data = get_historical_data(symbol, mt5.TIMEFRAME_H1, start_date, end_date)
            if backtest_data is not None and not backtest_data.empty:
                logging.info(f"Backtest data shape: {backtest_data.shape}")
                logging.info(f"Backtest data head:\n{backtest_data.head()}")
            else:
                logging.error(f"No historical data retrieved for {symbol} for backtesting")
                continue

            # Ensure there are enough data points for the indicators
            if len(backtest_data) < 20:
                logging.error(f"Not enough data for symbol {symbol} to perform backtest")
                continue

            # Process data to avoid SettingWithCopyWarning
            backtest_data.loc[:, 'close'] = pd.to_numeric(backtest_data['close'], errors='coerce')

            try:
                run_backtest(
                    symbol=symbol,
                    data=backtest_data,
                    initial_balance=initial_balance,
                    risk_percent=risk_percent,
                    min_take_profit=Config.MIN_TP_PROFIT,
                    max_loss_per_day=Config.MAX_LOSS_PER_DAY,
                    starting_equity=Config.STARTING_EQUITY,
                    max_trades_per_day=Config.LIMIT_NO_OF_TRADES,
                    stop_loss_pips=stop_loss_pips,  # Pass stop_loss_pips
                    pip_value=pip_value              # Pass pip_value
                )
                logging.info("Backtest completed successfully.")
            except Exception as e:
                handle_error(e, f"An error occurred during backtesting for {symbol}")

    except Exception as e:
        error_code = mt5.last_error()
        error_message = str(e)
        handle_error(e, f"An error occurred in the run_backtest_func: {error_code} - {error_message}")

    finally:
        logging.info("Shutting down MetaTrader5...")
        shutdown_mt5()
        logging.info("MetaTrader5 connection gracefully shut down.")

def run_live_trading_func():
    try:
        # Initialize MetaTrader5
        logging.info("Initializing MetaTrader5...")
        if not initialize_mt5(Config.MT5_PATH):
            raise Exception("Failed to initialize MetaTrader5")
        logging.info("MetaTrader5 initialized successfully.")

        for symbol in Config.SYMBOLS:
            logging.info("Running live trading...")
            run_strategy(
                symbols=[symbol],
                mt5_init=mt5,
                timeframe=mt5.TIMEFRAME_M1,
                lot_size=0.01,
                min_take_profit=Config.MIN_TP_PROFIT,
                max_loss_per_day=Config.MAX_LOSS_PER_DAY,
                starting_equity=Config.STARTING_EQUITY,
                max_trades_per_day=Config.LIMIT_NO_OF_TRADES,
                run_backtest=False
            )
            logging.info("Live trading completed.")

    except Exception as e:
        error_code = mt5.last_error()
        error_message = str(e)
        handle_error(e, f"An error occurred in the run_live_trading_func: {error_code} - {error_message}")

    finally:
        logging.info("Shutting down MetaTrader5...")
        shutdown_mt5()
        logging.info("MetaTrader5 connection gracefully shut down.")

def open_log_file():
    import subprocess
    log_file_path = os.path.abspath("app.log")
    if os.name == "nt":  # for Windows
        os.startfile(log_file_path)
    elif os.name == "posix":  # for MacOS and Linux
        subprocess.call(["open", log_file_path])

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--ui", action="store_true", help="Run the UI")
    args = parser.parse_args()

    try:
        setup_logging()
        logging.info("STARTING APPLICATION")

        # Log configuration settings
        logging.info("LOGGING ALL THE CONFIG SETTINGS")
        Config.log_config()

        if args.ui:
            run_ui(run_backtest_func, run_live_trading_func, clear_log_file, open_log_file)
        else:
            # Prompt the user to choose between backtesting and live trading
            print("Choose an option:")
            print("1. Run Backtesting")
            print("2. Run Live Trading")
            choice = input("Enter your choice (1 or 2): ")

            if choice == "1":
                run_backtest_func()
            elif choice == "2":
                run_live_trading_func()
            else:
                print("Invalid choice. Exiting...")

    except Exception as e:
        error_code = mt5.last_error()
        error_message = str(e)
        handle_error(e, f"An error occurred in the main function: {error_code} - {error_message}")

if __name__ == '__main__':
    main()

</document_content>
</document>

<document index="3">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\scheduler.py</source>
<document_content>
import schedule
import time
import logging
from strategy.tunnel_strategy import run_strategy
from metatrader.connection import initialize_mt5
from config import Config
from utils.error_handling import handle_error, warn_error
from strategy.trade_logic import calculate_position_size, entry_long, entry_short, exit_trade
from utils.data_validation import validate_data, sanitize_data
from metatrader.trade_management import get_open_positions, should_exit_position

def initialize_strategy():
    try:
        logging.info("Initializing strategy on server: %s", Config.MT5_SERVER)
        mt5_init = initialize_mt5(
            login=Config.MT5_LOGIN,
            password=Config.MT5_PASSWORD,
            server=Config.MT5_SERVER,
            path=Config.MT5_PATH,
        )

        run_strategy(
            symbols=Config.SYMBOLS,
            mt5_init=mt5_init,
            timeframe=Config.MT5_TIMEFRAME,
            lot_size=Config.MT5_LOT_SIZE,
            min_take_profit=Config.MIN_TP_PROFIT,
            max_loss_per_day=Config.MAX_LOSS_PER_DAY,
            starting_equity=Config.STARTING_EQUITY,
            max_traders_per_day=Config.LIMIT_NO_OF_TRADES
        )
    except Exception as e:
        warn_error(e, "Error initializing strategy")

def run_scheduled_tasks():
    while True:
        try:
            schedule.run_pending()
            time.sleep(1)
        except Exception as e:
            handle_error(e, "Error during scheduled task execution")

def run_trading_task():
    try:
        account_info = get_account_info()
        account_balance = account_info["balance"]

        for symbol in Config.SYMBOLS:
            data = get_historical_data(symbol, Config.MT5_TIMEFRAME, start_time, end_time)
            sanitized_data = sanitize_data(data)

            if validate_data(sanitized_data, TradeRequestSchema.schema()):
                signal = generate_trade_signal(sanitized_data, period, deviation)
                price = sanitized_data["close"].iloc[-1]
                stop_loss_pips = 20
                take_profit_pips = 40
                deviation = 10
                magic = 12345
                comment = "Tunnel Strategy"

                position_size = calculate_position_size(account_balance, Config.RISK_PER_TRADE, stop_loss_pips, Config.PIP_VALUE)

                if signal == 'BUY':
                    sl = price - (stop_loss_pips * Config.PIP_VALUE)
                    tp = price + (take_profit_pips * Config.PIP_VALUE)
                    entry_long(symbol, position_size, price, sl, tp, deviation, magic, comment)
                elif signal == 'SELL':
                    sl = price + (stop_loss_pips * Config.PIP_VALUE)
                    tp = price - (take_profit_pips * Config.PIP_VALUE)
                    entry_short(symbol, position_size, price, sl, tp, deviation, magic, comment)
            else:
                logging.error("Invalid input data")

        open_positions = get_open_positions()
        for position in open_positions:
            if should_exit_position(position):
                exit_trade(position.ticket)

    except Exception as e:
        handle_error(e, "Failed to execute trading task or validate/sanitize input data")

def setup_schedule():
    schedule.every().day.at("09:00").do(initialize_strategy)
    schedule.every(15).minutes.do(run_trading_task)
    logging.info("Scheduler setup complete. Next run at: %s", schedule.next_run())

def adjust_schedule(market_conditions):
    if market_conditions == 'volatile':
        schedule.every(5).minutes.do(run_trading_task)
    elif market_conditions == 'calm':
        schedule.every(30).minutes.do(run_trading_task)

# Call adjust_schedule() based on market conditions
market_conditions = analyze_market_conditions()
adjust_schedule(market_conditions)
</document_content>
</document>

<document index="4">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\ui.py</source>
<document_content>
import tkinter as tk
from tkinter import ttk
from config import Config
import ast
import os
import threading
import logging

class LogHandler(logging.Handler):
    def __init__(self, text_widget):
        super().__init__()
        self.text_widget = text_widget

    def emit(self, record):
        msg = self.format(record)
        self.text_widget.configure(state='normal')
        self.text_widget.insert(tk.END, msg + '\n')
        self.text_widget.configure(state='disabled')
        self.text_widget.yview(tk.END)

def run_ui(run_backtest_func, run_live_trading_func, clear_log_file, open_log_file):
    window = tk.Tk()
    window.title("Wavy Tunnel Bot")
    window.geometry("800x600")

    def update_config():
        config_values = {}
        for attr, entry in config_entries.items():
            value = entry.get()
            if value != "":
                try:
                    config_values[attr] = ast.literal_eval(value)
                except (ValueError, SyntaxError):
                    config_values[attr] = value

        for attr, value in config_values.items():
            setattr(Config, attr, value)

        mode_window.deiconify()
        config_window.withdraw()

    def open_config_window():
        mode_window.withdraw()
        config_window.deiconify()

    def run_backtest():
        log_text.configure(state='normal')
        log_text.delete(1.0, tk.END)
        log_text.configure(state='disabled')
        clear_log_file()
        log_text.insert(tk.END, "Backtesting running...\n")
        threading.Thread(target=run_backtest_thread).start()

    def run_backtest_thread():
        run_backtest_func()
        log_text.insert(tk.END, "Backtesting completed.\n")
        open_log_file()

    def run_live_trading():
        log_text.configure(state='normal')
        log_text.delete(1.0, tk.END)
        log_text.configure(state='disabled')
        clear_log_file()
        log_text.insert(tk.END, "Live trading running...\n")
        threading.Thread(target=run_live_trading_thread).start()

    def run_live_trading_thread():
        run_live_trading_func()
        log_text.insert(tk.END, "Live trading completed.\n")
        open_log_file()

    def clear_log():
        clear_log_file()
        log_clear_label.config(text="Log file cleared.")

    def open_log():
        open_log_file()

    # Apply a theme
    style = ttk.Style()
    style.theme_use('clam')

    # Main Mode Selection Window
    mode_window = window
    mode_window.title("Wavy Tunnel Bot")
    mode_window.geometry("800x600")

    mode_label = ttk.Label(mode_window, text="Select Mode", font=("Arial", 16))
    mode_label.pack(pady=20)

    backtest_button = ttk.Button(mode_window, text="Run Backtesting", command=run_backtest)
    backtest_button.pack(pady=10)

    live_trading_button = ttk.Button(mode_window, text="Run Live Trading", command=run_live_trading)
    live_trading_button.pack(pady=10)

    config_button = ttk.Button(mode_window, text="Configuration Settings", command=open_config_window)
    config_button.pack(pady=10)

    clear_log_button = ttk.Button(mode_window, text="Clear Log File", command=clear_log)
    clear_log_button.pack(pady=10)

    log_clear_label = ttk.Label(mode_window, text="")
    log_clear_label.pack(pady=10)

    open_log_button = ttk.Button(mode_window, text="Open Log File", command=open_log)
    open_log_button.pack(pady=10)

    # Terminal-like window for logs
    log_frame = ttk.Frame(mode_window)
    log_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

    log_text = tk.Text(log_frame, wrap=tk.WORD, height=20, state=tk.DISABLED)
    log_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    log_scrollbar = ttk.Scrollbar(log_frame, command=log_text.yview)
    log_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    log_text.config(yscrollcommand=log_scrollbar.set)

    # Add the log handler
    handler = LogHandler(log_text)
    handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
    logging.getLogger().addHandler(handler)
    logging.getLogger().setLevel(logging.INFO)

    # Configuration Settings Window
    config_window = tk.Toplevel(window)
    config_window.title("Configuration Settings")
    config_window.geometry("800x600")
    config_window.withdraw()

    config_label = ttk.Label(config_window, text="Configuration Settings", font=("Arial", 16))
    config_label.pack(pady=20)

    config_canvas = tk.Canvas(config_window)
    config_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

    scrollbar = ttk.Scrollbar(config_window, orient=tk.VERTICAL, command=config_canvas.yview)
    scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    config_canvas.configure(yscrollcommand=scrollbar.set)
    config_canvas.bind('<Configure>', lambda e: config_canvas.configure(scrollregion=config_canvas.bbox('all')))

    config_frame = ttk.Frame(config_canvas)
    config_canvas.create_window((0, 0), window=config_frame, anchor='nw')

    config_entries = {}
    for attr, value in Config.__dict__.items():
        if not callable(value) and not attr.startswith("__") and attr not in ["validate", "log_config"]:
            attr_label = ttk.Label(config_frame, text=attr)
            attr_label.grid(row=len(config_entries), column=0, padx=5, pady=5, sticky="e")

            attr_entry = ttk.Entry(config_frame, width=40)
            attr_entry.insert(0, str(value))
            attr_entry.grid(row=len(config_entries), column=1, padx=5, pady=5)

            config_entries[attr] = attr_entry

    update_button = ttk.Button(config_window, text="Update Settings", command=update_config)
    update_button.pack(pady=10)

    window.mainloop()

</document_content>
</document>

<document index="5">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\backtesting\backtest.py</source>
<document_content>
import logging
import pandas as pd
import numpy as np
import pstats
from io import StringIO
from strategy.tunnel_strategy import generate_trade_signal, calculate_position_size, detect_peaks_and_dips, manage_position, check_entry_conditions
from metatrader.indicators import calculate_ema
from metatrader.trade_management import execute_trade
import cProfile

# Initialize the logger
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

def run_backtest(symbol, data, initial_balance, risk_percent, min_take_profit, max_loss_per_day, starting_equity, stop_loss_pips, pip_value, max_trades_per_day=None, slippage=0, transaction_cost=0, enable_profiling=False):
    # Initialize the profiler if profiling is enabled
    pr = cProfile.Profile() if enable_profiling else None
    if enable_profiling:
        pr.enable()

    # Check for zero or negative initial balance
    if initial_balance <= 0:
        raise ValueError("Initial balance must be greater than zero.")
    
    # Check for zero risk percentage
    if risk_percent == 0:
        raise ValueError("Risk percentage cannot be zero.")

    try:
        balance = initial_balance
        trades = []
        trades_today = 0
        current_day = data.iloc[0]['time'].date()
        peak_type = 21

        data = data.copy()  # Make a copy to avoid modifying the original DataFrame

        # Handle missing values by interpolation
        data['high'] = data['high'].interpolate(method='linear')
        data['close'] = data['close'].interpolate(method='linear')
        data['low'] = data['low'].interpolate(method='linear')

        # Check if the DataFrame has enough rows for EMA calculation
        if len(data) < 200:
            raise ValueError("Not enough data to calculate required EMAs. Ensure data has at least 200 rows.")

        # Log the data length before EMA calculation
        logger.debug(f"Data length for 'high': {len(data['high'])}, 'low': {len(data['low'])}, 'close': {len(data['close'])}")

        # Calculate EMAs
        data.loc[:, 'wavy_h'] = calculate_ema(data['high'], 34)
        data.loc[:, 'wavy_c'] = calculate_ema(data['close'], 34)
        data.loc[:, 'wavy_l'] = calculate_ema(data['low'], 34)
        data.loc[:, 'tunnel1'] = calculate_ema(data['close'], 144)
        data.loc[:, 'tunnel2'] = calculate_ema(data['close'], 169)
        data.loc[:, 'long_term_ema'] = calculate_ema(data['close'], 200)

        # Peak and Dip detection
        peaks, dips = detect_peaks_and_dips(data, peak_type)

        # Loop through the data
        for i in range(34, len(data)):
            row = data.iloc[i]
            if row['time'].date() != current_day:
                current_day = row['time'].date()
                trades_today = 0
                daily_loss = 0
                logger.info(f"New trading day: {current_day}, resetting daily counters.")

            if max_trades_per_day is not None and trades_today >= max_trades_per_day:
                logger.info(f"Reached max trades per day: {max_trades_per_day}, skipping further trades for {current_day}.")
                continue

            buy_condition, sell_condition = check_entry_conditions(row, peaks, dips, symbol)

            if buy_condition is None or sell_condition is None:
                logger.debug(f"No trade signal generated for {row['time']}.")
                continue

            try:
                position_size = calculate_position_size(balance, risk_percent, stop_loss_pips, pip_value)
            except ZeroDivisionError as e:
                logger.warning(f"Zero division error while calculating position size: {e}")
                continue

            std_dev = data['close'].rolling(window=20).std().iloc[i]

            if buy_condition and (max_trades_per_day is None or trades_today < max_trades_per_day):
                trade = {
                    'entry_time': row['time'],
                    'entry_price': row['close'],
                    'volume': position_size,
                    'symbol': symbol,
                    'action': 'BUY',
                    'sl': row['close'] - (1.5 * std_dev),
                    'tp': row['close'] + (2 * std_dev),
                    'profit': 0  # Initialize profit to 0
                }
                execute_trade(trade)
                trades.append(trade)
                trades_today += 1
                logger.info(f"Executed BUY trade at {trade['entry_time']}, price: {trade['entry_price']}, volume: {trade['volume']}.")

            elif sell_condition and (max_trades_per_day is None or trades_today < max_trades_per_day):
                trade = {
                    'entry_time': row['time'],
                    'entry_price': row['close'],
                    'volume': position_size,
                    'symbol': symbol,
                    'action': 'SELL',
                    'sl': row['close'] + (1.5 * std_dev),
                    'tp': row['close'] - (2 * std_dev),
                    'profit': 0  # Initialize profit to 0
                }
                execute_trade(trade)
                trades.append(trade)
                trades_today += 1
                logger.info(f"Executed SELL trade at {trade['entry_time']}, price: {trade['entry_price']}, volume: {trade['volume']}.")

            manage_position(symbol, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day)

        # Calculate profits/losses for each trade
        for trade in trades:
            exit_price = trade['tp'] if trade['action'] == 'BUY' else trade['sl']
            if trade['action'] == 'BUY':
                trade['profit'] = (exit_price - trade['entry_price']) * trade['volume'] - slippage - transaction_cost
            else:
                trade['profit'] = (trade['entry_price'] - exit_price) * trade['volume'] - slippage - transaction_cost
            logger.info(f"Trade closed at {trade['entry_time']}, action: {trade['action']}, profit: {trade['profit']}.")

        total_profit = sum(trade.get('profit', 0) for trade in trades)
        num_trades = len(trades)
        win_rate = sum(1 for trade in trades if trade.get('profit', 0) > 0) / num_trades if num_trades > 0 else 0
        max_drawdown = calculate_max_drawdown(trades, initial_balance)
        
        final_balance = balance + total_profit

        logger.info(f"Backtest completed. Total Profit: {total_profit}, Final Balance: {final_balance}, Number of Trades: {num_trades}, Win Rate: {win_rate}, Max Drawdown: {max_drawdown}.")

        return {
            'total_profit': total_profit,
            'final_balance': final_balance,
            'num_trades': num_trades,
            'win_rate': win_rate,
            'max_drawdown': max_drawdown,
            'buy_condition': buy_condition,
            'sell_condition': sell_condition,
            'trades': trades,
            'total_slippage_costs': len(trades) * slippage,
            'total_transaction_costs': len(trades) * transaction_cost
        }

    finally:
        if enable_profiling and pr:
            pr.disable()
            s = StringIO()
            ps = pstats.Stats(pr, stream=s).sort_stats(pstats.SortKey.CUMULATIVE)
            ps.print_stats()
            print(s.getvalue())

def calculate_max_drawdown(trades, initial_balance):
    balance = initial_balance
    max_balance = initial_balance
    max_drawdown = 0

    for trade in trades:
        if 'profit' in trade:
            balance += trade['profit']
            max_balance = max(max_balance, balance)
            drawdown = max_balance - balance
            max_drawdown = max(max_drawdown, drawdown)

    return max_drawdown

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)

</document_content>
</document>

<document index="6">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\metatrader\connection.py</source>
<document_content>
import MetaTrader5 as mt5
# import MetaTrader4 as mt4
import win32com.client
import time

def connect(login, password, server, path, mt_version):
    if mt_version == 5:
        if not mt5.initialize(path=path, login=login, password=password, server=server):
            print("initialize() failed for MT5, error code =", mt5.last_error())
            return False
        return True
    # elif mt_version == 4:
    #     try:
    #         mt4_client = mt4.MT4()
    #         mt4_client.Connect(server, login, password, "")
    #         return True
    #     except Exception as e:
    #         print("initialize() failed for MT4, error =", e)
    #         return False
    else:
        raise ValueError("Invalid MetaTrader version. Please specify 4 or 5.")

def disconnect(mt_version):
    if mt_version == 5:
        mt5.shutdown()
    # elif mt_version == 4:
    #     try:
    #         mt4_client = mt4.MT4()
    #         mt4_client.Disconnect()
    #     except Exception as e:
    #         print("disconnect() failed for MT4, error =", e)

def check_connection(mt_version):
    if mt_version == 5:
        return mt5.terminal_info() is not None
    # elif mt_version == 4:
    #     try:
    #         mt4_client = mt4.MT4()
    #         return mt4_client.IsConnected()
    #     except Exception as e:
    #         print("check_connection() failed for MT4, error =", e)
    #         return False
    # else:
    #     raise ValueError("Invalid MetaTrader version. Please specify 4 or 5.")

def initialize_mt5(mt5_path):
    if not mt5_path:
        print("Invalid path provided for MetaTrader 5 terminal.")
        return False

    if not mt5.initialize(path=mt5_path):
        print("Failed to initialize MetaTrader 5 terminal.")
        mt5.shutdown()
        return False
    else:
        print("MetaTrader 5 terminal initialized successfully.")
        return True


def shutdown_mt5():
    # Shutdown MetaTrader 5
    mt5.shutdown()
    print("MetaTrader 5 connection gracefully shut down.")

</document_content>
</document>

<document index="7">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\metatrader\data_retrieval.py</source>
<document_content>
import MetaTrader5 as mt5
import pandas as pd
import requests_cache
from datetime import datetime, timedelta
from requests_cache import CachedSession
from utils.error_handling import handle_error


def initialize_mt5():
    if not mt5.initialize():
        print("Failed to initialize MetaTrader5")
        mt5.shutdown()
        return False
    return True

def shutdown_mt5():
    mt5.shutdown()

start_time = datetime.now() - timedelta(days=30)  # Example: 30 days ago
end_time = datetime.now()  # Current time

def get_historical_data(symbol, timeframe, start_time, end_time):
    try:
        # Retrieve data from MT5
        rates = mt5.copy_rates_range(symbol, timeframe, start_time, end_time)
        if rates is None or len(rates) == 0:
            raise ValueError(f"Failed to retrieve historical data for {symbol} with timeframe {timeframe} from {start_time} to {end_time}")
        
        data = pd.DataFrame(rates, columns=['time', 'open', 'high', 'low', 'close', 'tick_volume', 'spread', 'real_volume'])
        data['time'] = pd.to_datetime(data['time'], unit='s')
        
        print(f"Historical data shape after retrieval: {data.shape}")
        print(f"Historical data head after retrieval:\n{data.head()}")
        
        if data.empty:
            raise ValueError(f"No historical data retrieved for {symbol} with timeframe {timeframe} from {start_time} to {end_time}")

        # Data Cleaning
        data = data.dropna()  # Drop missing values
        data = data[(data['open'] > 0) & (data['high'] > 0) & (data['low'] > 0) & (data['close'] > 0)]  # Remove zero/negative prices
        
        return data
    except Exception as e:
        handle_error(e, f"Failed to retrieve historical data for {symbol}")
        return None

def retrieve_historical_data(symbol, start_date, end_date, timeframe):
    rates = mt5.copy_rates_range(symbol, timeframe, start_date, end_date)
    data = pd.DataFrame(rates, columns=['time', 'open', 'high', 'low', 'close', 'tick_volume', 'spread', 'real_volume'])
    data['time'] = pd.to_datetime(data['time'], unit='s')
    return data

def get_current_price(symbol):
    prices = mt5.symbol_info_tick(symbol)
    if prices:
        return prices.last
    else:
        print(f"Failed to retrieve current price for {symbol}")
        return None

def get_account_info():
    account_info = mt5.account_info()
    if account_info:
        return account_info._asdict()
    else:
        print("Failed to retrieve account information")
        return None

def get_available_symbols():
    symbols = mt5.symbols_get()
    if symbols:
        return [symbol.name for symbol in symbols]
    else:
        print("Failed to retrieve available symbols")
        return None

def get_symbol_info(symbol):
    symbol_info = mt5.symbol_info(symbol)
    if symbol_info:
        return symbol_info._asdict()
    else:
        print(f"Failed to retrieve information for {symbol}")
        return None

def get_positions():
    positions = mt5.positions_get()
    if positions:
        positions_data = []
        for position in positions:
            position_data = position._asdict()
            positions_data.append(position_data)
        return positions_data
    else:
        print("No open positions found")
        return None

def get_orders():
    orders = mt5.orders_get()
    if orders:
        orders_data = []
        for order in orders:
            order_data = order._asdict()
            orders_data.append(order_data)
        return orders_data
    else:
        print("No pending orders found")
        return None

if __name__ == '__main__':
    if initialize_mt5():
        symbol = "EURUSD"
        timeframe = mt5.TIMEFRAME_H1
        start_time = datetime(2023, 1, 1)
        end_time = datetime.now()

        historical_data = get_historical_data(symbol, timeframe, start_time, end_time)
        if historical_data is not None:
            print(f"Historical data for {symbol}:")
            print(historical_data.head())

        current_price = get_current_price(symbol)
        if current_price is not None:
            print(f"Current price for {symbol}: {current_price}")

        account_info = get_account_info()
        if account_info is not None:
            print("Account information:")
            print(account_info)

        available_symbols = get_available_symbols()
        if available_symbols is not None:
            print("Available symbols:")
            print(available_symbols)

        symbol_info = get_symbol_info(symbol)
        if symbol_info is not None:
            print(f"Symbol information for {symbol}:")
            print(symbol_info)

        positions = get_positions()
        if positions is not None:
            print("Open positions:")
            print(positions)

        orders = get_orders()
        if orders is not None:
            print("Pending orders:")
            print(orders)

        shutdown_mt5()
</document_content>
</document>

<document index="8">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\metatrader\indicators.py</source>
<document_content>
import pandas as pd
import numpy as np
import logging

def calculate_ema(prices, period):
    if not isinstance(prices, (list, np.ndarray, pd.Series)):
        raise ValueError("Invalid input type for prices. Expected list, numpy array, or pandas Series.")
    
    logging.debug(f"Calculating EMA for period: {period}, prices: {prices}")
    
    # Convert input to a pandas Series to ensure consistency
    prices = pd.Series(prices)
    
    # Ensure that the series is numeric
    prices = pd.to_numeric(prices, errors='coerce')
    logging.debug(f"Prices converted to numeric: {prices}")

    ema_values = np.full(len(prices), np.nan, dtype=np.float64)
    if len(prices) < period:
        return pd.Series(ema_values, index=prices.index)
    
    sma = np.mean(prices[:period])
    ema_values[period - 1] = sma
    logging.debug(f"Initial SMA: {sma}")
    
    multiplier = 2 / (period + 1)
    for i in range(period, len(prices)):
        ema_values[i] = (prices[i] - ema_values[i - 1]) * multiplier + ema_values[i - 1]
        logging.debug(f"EMA value at index {i}: {ema_values[i]}")
    
    ema_series = pd.Series(ema_values, index=prices.index)
    return ema_series

</document_content>
</document>

<document index="9">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\metatrader\trade_management.py</source>
<document_content>
import MetaTrader5 as mt5

def place_order(symbol, order_type, volume, price=None, sl=None, tp=None):
    try:
        order = mt5.ORDER_TYPE_BUY if order_type == 'buy' else mt5.ORDER_TYPE_SELL
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": volume,
            "type": order,
            "price": mt5.symbol_info_tick(symbol).ask if order_type == 'buy' else mt5.symbol_info_tick(symbol).bid,
            "sl": sl,
            "tp": tp,
            "deviation": 10,
            "magic": 234000,
            "comment": "python script order",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_IOC,
        }
        result = mt5.order_send(request)
        return result.comment if result else 'Order failed'
    except Exception as e:
        return f'Order failed: {str(e)}'

def close_position(ticket):
    try:
        position = mt5.positions_get(ticket=ticket)
        if position:
            result = mt5.Close(ticket)
            return result.comment if result else 'Close failed'
        return 'Position not found'
    except Exception as e:
        return f'Close failed: {str(e)}'

def modify_order(ticket, sl=None, tp=None):
    try:
        result = mt5.order_check(ticket)
        if result and result.type in [mt5.ORDER_TYPE_BUY, mt5.ORDER_TYPE_SELL]:
            request = {
                "action": mt5.TRADE_ACTION_SLTP,
                "ticket": ticket,
                "sl": sl,
                "tp": tp
            }
            result = mt5.order_send(request)
            return result.comment if result else 'Modify failed'
        return 'Order not found'
    except Exception as e:
        return f'Modify failed: {str(e)}'

def execute_trade(trade):
    """
    Executes a trade based on the provided trade dictionary.
    Expected dictionary keys: 'symbol', 'action', 'volume', 'price', 'sl', 'tp'.
    """
    symbol = trade.get('symbol')
    action = trade.get('action')
    volume = trade.get('volume')
    price = trade.get('price')
    sl = trade.get('sl')
    tp = trade.get('tp')
    
    if action == 'BUY':
        return place_order(symbol, 'buy', volume, price, sl, tp)
    elif action == 'SELL':
        return place_order(symbol, 'sell', volume, price, sl, tp)
    else:
        return 'Invalid trade action'

</document_content>
</document>

<document index="10">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\metatrader\__init__.py</source>
<document_content>
from .data_retrieval import get_historical_data
# tests/__init__.py
import unittest

def suite():
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    suite.addTests(loader.discover('C:\\Users\\16198\\Desktop\\automation\\upwork\\wavy\\wavy_tunnel_bot\\tests', pattern='test_*.py'))
    return suite

if __name__ == '__main__':
    runner = unittest.TextTestRunner()
    runner.run(suite())
</document_content>
</document>

<document index="11">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\strategy\trade_logic.py</source>
<document_content>
from strategy.tunnel_strategy import execute_trade, manage_position
from utils.error_handling import handle_error
import logging

def calculate_position_size(balance, risk_percent, stop_loss_pips, pip_value):
    risk_amount = balance * risk_percent
    if stop_loss_pips == 0 or pip_value == 0:
        logging.error("stop_loss_pips or pip_value cannot be zero.")
        return 0  # Return 0 or handle the error appropriately

    position_size = risk_amount / (stop_loss_pips * pip_value)
    return position_size

def entry_long(symbol, lot_size, price, sl, tp, deviation, magic, comment):
    trade_request = {
        'action': 'BUY',
        'symbol': symbol,
        'volume': lot_size,
        'price': price,
        'sl': sl,
        'tp': tp,
        'deviation': deviation,
        'magic': magic,
        'comment': comment,
        'type': 'ORDER_TYPE_BUY',
        'type_filling': 'ORDER_FILLING_FOK',
        'type_time': 'ORDER_TIME_GTC'
    }
    return execute_trade(trade_request)

def entry_short(symbol, lot_size, price, sl, tp, deviation, magic, comment):
    trade_request = {
        'action': 'SELL',
        'symbol': symbol,
        'volume': lot_size,
        'price': price,
        'sl': sl,
        'tp': tp,
        'deviation': deviation,
        'magic': magic,
        'comment': comment,
        'type': 'ORDER_TYPE_SELL',
        'type_filling': 'ORDER_FILLING_FOK',
        'type_time': 'ORDER_TIME_GTC'
    }
    return execute_trade(trade_request)

def exit_trade(position_ticket):
    try:
        close_request = {
            'action': 'CLOSE',
            'position': position_ticket,
            'type': 'ORDER_TYPE_CLOSE',
            'type_filling': 'ORDER_FILLING_FOK',
            'type_time': 'ORDER_TIME_GTC'
        }
        return execute_trade(close_request)
    except Exception as e:
        handle_error(e, "Failed to close the trade")
        return False

</document_content>
</document>

<document index="12">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\strategy\tunnel_strategy.py</source>
<document_content>
import pandas as pd
import numpy as np
import logging
import MetaTrader5 as mt5

# Configure logging
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

def handle_error(e, context):
    logging.error(f"Error in {context}: {str(e)}")

def calculate_ema(prices, period):
    if not isinstance(prices, (list, np.ndarray, pd.Series)):
        raise ValueError("Invalid input type for prices. Expected list, numpy array, or pandas Series.")
    
    logging.debug(f"Calculating EMA for period: {period}, prices: {prices}")
    
    # Convert input to a pandas Series to ensure consistency
    prices = pd.Series(prices)
    
    # Ensure that the series is numeric
    prices = pd.to_numeric(prices, errors='coerce')
    logging.debug(f"Prices converted to numeric: {prices}")

    ema_values = np.full(len(prices), np.nan, dtype=np.float64)
    if len(prices) < period:
        return pd.Series(ema_values, index=prices.index)
    
    sma = np.mean(prices[:period])
    ema_values[period - 1] = sma
    logging.debug(f"Initial SMA: {sma}")
    
    multiplier = 2 / (period + 1)
    for i in range(period, len(prices)):
        ema_values[i] = (prices[i] - ema_values[i - 1]) * multiplier + ema_values[i - 1]
        logging.debug(f"EMA value at index {i}: {ema_values[i]}")
    
    ema_series = pd.Series(ema_values, index=prices.index)
    return ema_series

def detect_peaks_and_dips(df, peak_type):
    if not np.issubdtype(df['high'].dtype, np.number) or not np.issubdtype(df['low'].dtype, np.number):
        raise TypeError("High and Low columns must contain numeric data.")

    logging.debug(f"Detecting peaks and dips with peak_type: {peak_type}")
    
    highs = df['high'].values
    lows = df['low'].values
    center_index = peak_type // 2
    peaks = []
    dips = []
    
    for i in range(center_index, len(highs) - center_index):
        peak_window = highs[i - center_index:i + center_index + 1]
        dip_window = lows[i - center_index:i + center_index + 1]
        
        if all(peak_window[center_index] > peak_window[j] for j in range(len(peak_window)) if j != center_index):
            peaks.append(highs[i])
        
        if all(dip_window[center_index] < dip_window[j] for j in range(len(dip_window)) if j != center_index):
            dips.append(lows[i])
    
    logging.debug(f"Detected peaks: {peaks}")
    logging.debug(f"Detected dips: {dips}")
    
    return peaks, dips

def check_entry_conditions(row, peaks, dips, symbol):
    logging.debug(f"Checking entry conditions for row: {row}")
    logging.debug(f"Peaks: {peaks}")
    logging.debug(f"Dips: {dips}")

    wavy_c, wavy_h, wavy_l = row['wavy_c'], row['wavy_h'], row['wavy_l']
    tunnel1, tunnel2 = row['tunnel1'], row['tunnel2']
    close_price = row['close']

    logging.debug(f"wavy_c: {wavy_c}, wavy_h: {wavy_h}, wavy_l: {wavy_l}")
    logging.debug(f"tunnel1: {tunnel1}, tunnel2: {tunnel2}")
    logging.debug(f"close_price: {close_price}")

    buy_condition = (
        close_price > max(wavy_c, wavy_h, wavy_l) and
        min(wavy_c, wavy_h, wavy_l) > max(tunnel1, tunnel2) and
        any(abs(close_price - peak) <= 0.001 for peak in peaks)
    )
    sell_condition = (
        close_price < min(wavy_c, wavy_h, wavy_l) and
        max(wavy_c, wavy_h, wavy_l) < min(tunnel1, tunnel2) and
        any(abs(close_price - dip) <= 0.001 for dip in dips)
    )
    
    logging.debug(f"Initial Buy condition: {buy_condition}")
    logging.debug(f"Initial Sell condition: {sell_condition}")

    threshold_values = {
        'USD': 2,
        'EUR': 2,
        'JPY': 300,
        'GBP': 6,
        'CHF': 2,
        'AUD': 2,
        'default': 100
    }
    apply_threshold = True
    if apply_threshold:
        symbol_info = mt5.symbol_info(symbol)
        if not symbol_info:
            logging.error(f"Failed to get symbol info for {symbol}")
            return False, False
        
        threshold = threshold_values.get(symbol[:3], threshold_values['default']) * symbol_info.trade_tick_size
        logging.debug(f"Threshold: {threshold}")

        if threshold == 0:
            logging.error("Division by zero: threshold value is zero in check_entry_conditions")
            return False, False

        buy_condition &= close_price > max(wavy_c, wavy_h, wavy_l) + threshold
        sell_condition &= close_price < min(wavy_c, wavy_h, wavy_l) - threshold

    logging.debug(f"Final Buy condition: {buy_condition}")
    logging.debug(f"Final Sell condition: {sell_condition}")

    return buy_condition, sell_condition

def execute_trade(trade_request):
    logging.debug(f"Executing trade with request: {trade_request}")
    try:
        # Set initial trade details
        trade_request['entry_time'] = pd.Timestamp.now()
        trade_request['entry_price'] = trade_request['price']
        trade_request['profit'] = 0  # Initialize profit to 0

        # Place the order (simulated for this example)
        result = place_order(
            trade_request['symbol'],
            trade_request['action'].lower(),
            trade_request['volume'],
            trade_request['entry_price'],
            trade_request['sl'],
            trade_request['tp']
        )

        if result == 'Order failed':
            raise Exception("Failed to execute trade")

        logging.debug(f"Trade executed successfully: {result}")
        return result
    except Exception as e:
        handle_error(e, "Failed to execute trade")
        return None

def manage_position(symbol, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day):
    logging.debug(f"Managing position for symbol: {symbol}")
    try:
        positions = mt5.positions_get(symbol=symbol)
        if positions:
            for position in positions:
                logging.debug(f"Checking position {position.ticket} with profit {position.profit}")

                current_equity = mt5.account_info().equity

                # Check for take profit, stop loss, or maximum loss per day conditions
                if position.profit >= min_take_profit:
                    logging.debug(f"Closing position {position.ticket} for profit")
                    close_position(position.ticket)
                    position['exit_time'] = pd.Timestamp.now()
                    position['exit_price'] = mt5.symbol_info_tick(symbol).bid
                    position['profit'] = (position['exit_price'] - position['entry_price']) * position['volume']

                elif position.profit <= -max_loss_per_day:
                    logging.debug(f"Closing position {position.ticket} for loss")
                    close_position(position.ticket)
                    position['exit_time'] = pd.Timestamp.now()
                    position['exit_price'] = mt5.symbol_info_tick(symbol).bid
                    position['profit'] = (position['exit_price'] - position['entry_price']) * position['volume']

                elif current_equity <= starting_equity * 0.9:  # Close position if equity drops by 10%
                    logging.debug(f"Closing position {position.ticket} due to equity drop")
                    close_position(position.ticket)
                    position['exit_time'] = pd.Timestamp.now()
                    position['exit_price'] = mt5.symbol_info_tick(symbol).bid
                    position['profit'] = (position['exit_price'] - position['entry_price']) * position['volume']

                elif mt5.positions_total() >= max_trades_per_day:
                    logging.debug(f"Closing position {position.ticket} due to max trades exceeded")
                    close_position(position.ticket)
                    position['exit_time'] = pd.Timestamp.now()
                    position['exit_price'] = mt5.symbol_info_tick(symbol).bid
                    position['profit'] = (position['exit_price'] - position['entry_price']) * position['volume']
    except Exception as e:
        handle_error(e, "Failed to manage position")

def calculate_tunnel_bounds(data, period, deviation_factor):
    logging.debug(f"Calculating tunnel bounds with period: {period} and deviation_factor: {deviation_factor}")

    if len(data) < period:
        return pd.Series([np.nan] * len(data)), pd.Series([np.nan] * len(data))

    data = data.copy()  # Avoid SettingWithCopyWarning by operating on a copy
    data['close'] = pd.to_numeric(data['close'], errors='coerce')

    ema = calculate_ema(data['close'], period)
    rolling_std = data['close'].rolling(window=period).std()
    volatility = rolling_std * deviation_factor
    deviation = volatility / np.sqrt(period)
    upper_bound = ema + deviation
    lower_bound = ema - deviation

    logging.debug(f"EMA: {ema}")
    logging.debug(f"Rolling Std: {rolling_std}")
    logging.debug(f"Volatility: {volatility}")
    logging.debug(f"Deviation: {deviation}")
    logging.debug(f"Upper Bound: {upper_bound}")
    logging.debug(f"Lower Bound: {lower_bound}")

    return upper_bound, lower_bound

def calculate_position_size(account_balance, risk_per_trade, stop_loss_pips, pip_value):
    risk_amount = account_balance * risk_per_trade
    if stop_loss_pips == 0 or pip_value == 0:
        logging.error("Division by zero: stop_loss_pips or pip_value is zero in calculate_position_size")
        raise ZeroDivisionError("stop_loss_pips or pip_value cannot be zero")
    position_size = risk_amount / (stop_loss_pips * pip_value)
    logging.debug(f"Calculated position size: {position_size}")
    return position_size

def generate_trade_signal(data, period, deviation_factor):
    if len(data) < period:
        return None, None

    upper_bound, lower_bound = calculate_tunnel_bounds(data, period, deviation_factor)
    
    last_close = pd.to_numeric(data['close'].iloc[-1], errors='coerce')
    upper_bound_last_value = upper_bound.iloc[-1]
    lower_bound_last_value = lower_bound.iloc[-1]

    logging.debug(f"Data: {data}")
    logging.debug(f"Upper Bound: {upper_bound}")
    logging.debug(f"Lower Bound: {lower_bound}")
    logging.debug(f"Last Close: {last_close}")
    logging.debug(f"Upper Bound Last Value: {upper_bound_last_value}")
    logging.debug(f"Lower Bound Last Value: {lower_bound_last_value}")

    if pd.isna(last_close) or pd.isna(upper_bound_last_value) or pd.isna(lower_bound_last_value):
        return None, None

    buy_condition = last_close >= upper_bound_last_value
    sell_condition = last_close <= lower_bound_last_value

    logging.debug(f"Buy Condition: {buy_condition}")
    logging.debug(f"Sell Condition: {sell_condition}")

    return buy_condition, sell_condition

def adjust_deviation_factor(market_conditions):
    if market_conditions == 'volatile':
        return 2.5
    else:
        return 2.0

def run_strategy(symbols, mt5_init, timeframe, lot_size, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day, run_backtest=False):
    try:
        for symbol in symbols:
            start_time = pd.Timestamp.now() - pd.Timedelta(days=30)  # Example: 30 days ago
            end_time = pd.Timestamp.now()  # Current time
            data = get_historical_data(symbol, timeframe, start_time, end_time)
            if data is None or data.empty:
                raise ValueError(f"Failed to retrieve historical data for {symbol}")

            period = 20
            market_conditions = 'volatile'  # Placeholder for determining market conditions
            deviation_factor = adjust_deviation_factor(market_conditions)

            logging.info("Calculating Wavy Tunnel indicators...")
            data['wavy_h'] = calculate_ema(data['high'], 34)
            data['wavy_c'] = calculate_ema(data['close'], 34)
            data['wavy_l'] = calculate_ema(data['low'], 34)
            data['tunnel1'] = calculate_ema(data['close'], 144)
            data['tunnel2'] = calculate_ema(data['close'], 169)
            data['long_term_ema'] = calculate_ema(data['close'], 200)
            logging.info("Indicators calculated.")

            logging.info("Detecting peaks and dips...")
            peak_type = 21  # Define the peak_type variable
            peaks, dips = detect_peaks_and_dips(data, peak_type)
            logging.info(f"Peaks: {peaks[:5]}")
            logging.info(f"Dips: {dips[:5]}")

            logging.info(f"Historical data shape after calculations: {data.shape}")
            logging.info(f"Historical data head after calculations:\n{data.head()}")

            logging.info("Generating entry signals...")
            data['buy_signal'], data['sell_signal'] = zip(*data.apply(lambda x: check_entry_conditions(x, peaks, dips, symbol), axis=1))
            logging.info("Entry signals generated.")

            if run_backtest:
                logging.info("Running backtest...")
                backtest_result = run_backtest(
                    symbol=symbol,
                    data=data,
                    initial_balance=starting_equity,
                    risk_percent=0.01,
                    min_take_profit=min_take_profit,
                    max_loss_per_day=max_loss_per_day,
                    starting_equity=starting_equity,
                    stop_loss_pips=20,
                    pip_value=0.0001,
                    max_trades_per_day=max_trades_per_day,
                    slippage=0,
                    transaction_cost=0
                )
                logging.info(f"Backtest result: {backtest_result}")
            else:
                buy_condition, sell_condition = generate_trade_signal(data, period, deviation_factor)

                if buy_condition:
                    trade_request = {
                        'action': 'BUY',
                        'symbol': symbol,
                        'volume': lot_size,
                        'price': data['close'].iloc[-1],
                        'sl': data['close'].iloc[-1] - (1.5 * np.std(data['close'])),
                        'tp': data['close'].iloc[-1] + (2 * np.std(data['close'])),
                        'deviation': 10,
                        'magic': 12345,
                        'comment': 'Tunnel Strategy',
                        'type': 'ORDER_TYPE_BUY',
                        'type_filling': 'ORDER_FILLING_FOK',
                        'type_time': 'ORDER_TIME_GTC'
                    }
                    logging.info(f"Executing BUY trade for {symbol}...")
                    execute_trade(trade_request)
                elif sell_condition:
                    trade_request = {
                        'action': 'SELL',
                        'symbol': symbol,
                        'volume': lot_size,
                        'price': data['close'].iloc[-1],
                        'sl': data['close'].iloc[-1] + (1.5 * np.std(data['close'])),
                        'tp': data['close'].iloc[-1] - (2 * np.std(data['close'])),
                        'deviation': 10,
                        'magic': 12345,
                        'comment': 'Tunnel Strategy',
                        'type': 'ORDER_TYPE_SELL',
                        'type_filling': 'ORDER_FILLING_FOK',
                        'type_time': 'ORDER_TIME_GTC'
                    }
                    logging.info(f"Executing SELL trade for {symbol}...")
                    execute_trade(trade_request)

                manage_position(symbol, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day)

    except Exception as e:
        handle_error(e, "Failed to run the strategy")
        raise

def place_order(symbol, action, volume, price, sl, tp):
    """
    Simulate placing an order.
    
    Parameters:
        symbol (str): The symbol to trade.
        action (str): 'buy' or 'sell'.
        volume (float): The volume to trade.
        price (float): The price to execute the trade.
        sl (float): Stop loss price.
        tp (float): Take profit price.

    Returns:
        str: 'Order placed' if successful, 'Order failed' otherwise.
    """
    try:
        # In a real implementation, you would place the order with your trading platform here.
        logging.debug(f"Placing order: {action} {symbol} {volume} at {price}, SL: {sl}, TP: {tp}")
        return 'Order placed'
    except Exception as e:
        logging.error(f"Failed to place order: {str(e)}")
        return 'Order failed'

def close_position(ticket):
    """
    Simulate closing a position.
    
    Parameters:
        ticket (int): The ticket number of the position to close.

    Returns:
        str: 'Position closed' if successful, 'Close failed' otherwise.
    """
    try:
        # In a real implementation, you would close the position with your trading platform here.
        logging.debug(f"Closing position with ticket: {ticket}")
        return 'Position closed'
    except Exception as e:
        logging.error(f"Failed to close position: {str(e)}")
        return 'Close failed'

def get_historical_data(symbol, timeframe, start_time, end_time):
    """
    Simulate retrieving historical data.
    
    Parameters:
        symbol (str): The symbol to retrieve data for.
        timeframe (str): The timeframe to retrieve data for.
        start_time (datetime): The start time for the data retrieval.
        end_time (datetime): The end time for the data retrieval.

    Returns:
        pd.DataFrame: A DataFrame containing the historical data.
    """
    try:
        # Generate mock data for simplicity
        date_range = pd.date_range(start=start_time, end=end_time, freq='D')
        data = pd.DataFrame({
            'time': date_range,
            'open': np.random.rand(len(date_range)) * 100,
            'high': np.random.rand(len(date_range)) * 100,
            'low': np.random.rand(len(date_range)) * 100,
            'close': np.random.rand(len(date_range)) * 100,
            'volume': np.random.randint(100, 1000, size=len(date_range))
        })
        data.set_index('time', inplace=True)
        logging.debug(f"Retrieved historical data for {symbol}: {data.head()}")
        return data
    except Exception as e:
        logging.error(f"Failed to retrieve historical data for {symbol}: {str(e)}")
        return None

</document_content>
</document>

<document index="13">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\strategy\__init__.py</source>
<document_content>
from .tunnel_strategy import run_strategy
</document_content>
</document>

<document index="14">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\__init__.py</source>
<document_content>

</document_content>
</document>

<document index="15">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\integration\backtest_integration.py</source>
<document_content>
import logging
import unittest
import pandas as pd
import numpy as np
import MetaTrader5 as mt5
from unittest.mock import patch
from backtesting.backtest import run_backtest

class BacktestTestCase(unittest.TestCase):

    
    @classmethod
    def setUpClass(cls):
        # Initialize MetaTrader5
        if not mt5.initialize():
            raise RuntimeError("MetaTrader5 initialization failed")

        # Check symbol availability
        symbol = "EURUSD"
        if not mt5.symbol_select(symbol, True):
            raise RuntimeError(f"Failed to select symbol {symbol}")

    def setUp(self):
        # Dummy data for testing
        self.data = pd.DataFrame({
            'time': pd.date_range(start='2024-01-01', periods=200, freq='D'),
            'open': 1.0,
            'high': 1.2,
            'low': 0.8,
            'close': 1.0
        })

    def generate_large_dataset(self, start='2024-01-01', end='2024-01-31', freq='5min'):
        """
        Generates a large dataset with 5-minute interval data for the given date range.
        :param start: Start date of the dataset.
        :param end: End date of the dataset.
        :param freq: Frequency of data points, default is 5 minutes.
        :return: DataFrame with generated data.
        """
        date_range = pd.date_range(start=start, end=end, freq=freq)
        num_points = len(date_range)

        np.random.seed(0)  # For reproducibility

        data = {
            'time': date_range,
            'open': np.random.rand(num_points) * 100,
            'high': np.random.rand(num_points) * 100,
            'low': np.random.rand(num_points) * 100,
            'close': np.random.rand(num_points) * 100,
            'volume': np.random.randint(1, 100, num_points)
        }

        df = pd.DataFrame(data)

        # Ensure 'high' is always greater than or equal to 'low' and 'close' is within 'high' and 'low'
        df['high'] = df[['high', 'low']].max(axis=1)
        df['low'] = df[['high', 'low']].min(axis=1)
        df['close'] = df[['close', 'low', 'high']].apply(lambda x: np.clip(x[0], x[1], x[2]), axis=1)

        return df

    def run_backtest_and_print(self, test_name, **kwargs):
        print(f"\nRunning {test_name}")
        result = run_backtest(**kwargs)
        print(f"Result for {test_name}: {result}")
        return result

    def test_handling_large_datasets(self):
        large_data = self.generate_large_dataset()
        logging.debug(f"Generated dataset length: {len(large_data)}")
        
        result = self.run_backtest_and_print(
            'test_handling_large_datasets',
            symbol='EURUSD',
            data=large_data,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5
        )
        self.assertGreater(result['num_trades'], 0)

    # Add the rest of your test methods here
    def test_profit_factor_calculation(self):
        result = self.run_backtest_and_print(
            'test_profit_factor_calculation',
            symbol='EURUSD',
            data=self.data,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5
        )
        gross_profit = sum(trade['profit'] for trade in result['trades'] if trade['profit'] > 0)
        gross_loss = abs(sum(trade['profit'] for trade in result['trades'] if trade['profit'] < 0))
        profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
        self.assertAlmostEqual(result.get('profit_factor', profit_factor), profit_factor, places=2, msg="Profit factor calculation is incorrect.")

    def test_return_on_investment_calculation(self):
        result = self.run_backtest_and_print(
            'test_return_on_investment_calculation',
            symbol='EURUSD',
            data=self.data,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5
        )
        total_profit = result['total_profit']
        initial_balance = 10000
        roi = (total_profit / initial_balance) * 100
        self.assertAlmostEqual(result.get('roi', roi), roi, places=2, msg="ROI calculation is incorrect.")

    def test_sharpe_ratio_calculation(self):
        result = self.run_backtest_and_print(
            'test_sharpe_ratio_calculation',
            symbol='EURUSD',
            data=self.data,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5
        )
        returns = [trade['profit'] / 10000 for trade in result['trades']]
        avg_return = sum(returns) / len(returns) if returns else 0
        std_return = (sum((x - avg_return) ** 2 for x in returns) / len(returns)) ** 0.5 if returns else 0
        risk_free_rate = 0.01
        sharpe_ratio = (avg_return - risk_free_rate) / std_return if std_return != 0 else 0
        self.assertAlmostEqual(result.get('sharpe_ratio', sharpe_ratio), sharpe_ratio, places=2, msg="Sharpe ratio calculation is incorrect.")

    def test_win_loss_ratio_calculation(self):
        result = self.run_backtest_and_print(
            'test_win_loss_ratio_calculation',
            symbol='EURUSD',
            data=self.data,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5
        )
        wins = sum(1 for trade in result['trades'] if trade['profit'] > 0)
        losses = sum(1 for trade in result['trades'] if trade['profit'] < 0)
        win_loss_ratio = wins / losses if losses > 0 else float('inf')
        self.assertAlmostEqual(result.get('win_loss_ratio', win_loss_ratio), win_loss_ratio, places=2, msg="Win/Loss ratio calculation is incorrect.")

    def test_annualized_return_calculation(self):
        result = self.run_backtest_and_print(
            'test_annualized_return_calculation',
            symbol='EURUSD',
            data=self.data,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5
        )
        total_profit = result['total_profit']
        days = (self.data['time'].iloc[-1] - self.data['time'].iloc[0]).days
        annualized_return = ((total_profit / 10000) + 1) ** (365 / days) - 1 if days > 0 else 0
        self.assertAlmostEqual(result.get('annualized_return', annualized_return), annualized_return, places=2, msg="Annualized return calculation is incorrect.")

    def test_expectancy_calculation(self):
        result = self.run_backtest_and_print(
            'test_expectancy_calculation',
            symbol='EURUSD',
            data=self.data,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5
        )
        total_trades = len(result['trades'])
        wins = [trade['profit'] for trade in result['trades'] if trade['profit'] > 0]
        losses = [trade['profit'] for trade in result['trades'] if trade['profit'] < 0]
        avg_win = sum(wins) / len(wins) if wins else 0
        avg_loss = sum(losses) / len(losses) if losses else 0
        win_rate = len(wins) / total_trades if total_trades > 0 else 0
        loss_rate = len(losses) / total_trades if total_trades > 0 else 0
        expectancy = (avg_win * win_rate) - (avg_loss * loss_rate)
        self.assertAlmostEqual(result.get('expectancy', expectancy), expectancy, places=2, msg="Expectancy calculation is incorrect.")

    def test_consecutive_wins_and_losses(self):
        result = self.run_backtest_and_print(
            'test_consecutive_wins_and_losses',
            symbol='EURUSD',
            data=self.data,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5
        )
        max_consecutive_wins = 0
        max_consecutive_losses = 0
        current_wins = 0
        current_losses = 0

        for trade in result['trades']:
            if trade['profit'] > 0:
                current_wins += 1
                current_losses = 0
            else:
                current_losses += 1
                current_wins = 0

            max_consecutive_wins = max(max_consecutive_wins, current_wins)
            max_consecutive_losses = max(max_consecutive_losses, current_losses)

        self.assertEqual(result.get('max_consecutive_wins', max_consecutive_wins), max_consecutive_wins, "Max consecutive wins calculation is incorrect.")
        self.assertEqual(result.get('max_consecutive_losses', max_consecutive_losses), max_consecutive_losses, "Max consecutive losses calculation is incorrect.")

    def test_handling_missing_values(self):
        data_with_nans = self.data.copy()
        data_with_nans.loc[::10, 'close'] = float('nan')
        result = self.run_backtest_and_print(
            'test_handling_missing_values',
            symbol='EURUSD',
            data=data_with_nans,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5
        )
        self.assertIsNotNone(result, "Handling missing values failed.")

    def test_transaction_costs(self):
        result = self.run_backtest_and_print(
            'test_transaction_costs',
            symbol='EURUSD',
            data=self.data,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5,
            transaction_cost=1  # Adding transaction costs
        )
        total_transaction_costs = len(result['trades']) * 1
        self.assertAlmostEqual(result['total_transaction_costs'], total_transaction_costs, places=2, msg="Transaction costs calculation is incorrect.")

    def test_slippage(self):
        result = self.run_backtest_and_print(
            'test_slippage',
            symbol='EURUSD',
            data=self.data,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5,
            slippage=1  # Adding slippage
        )
        total_slippage_costs = len(result['trades']) * 1
        self.assertAlmostEqual(result['total_slippage_costs'], total_slippage_costs, places=2, msg="Slippage calculation is incorrect.")

    def test_negative_initial_balance(self):
    # Create a dataset with more price variation
        varied_data = pd.DataFrame({
            'time': pd.date_range(start='2024-01-01', periods=200, freq='D'),
            'open': np.random.uniform(50, 150, 200),
            'high': np.random.uniform(60, 160, 200),
            'low': np.random.uniform(40, 140, 200),
            'close': np.random.uniform(50, 150, 200)
        })

    # Ensure 'high' is always greater than or equal to 'low' and 'close' is within 'high' and 'low'
        varied_data['high'] = varied_data[['high', 'low']].max(axis=1)
        varied_data['low'] = varied_data[['high', 'low']].min(axis=1)
        varied_data['close'] = varied_data[['close', 'low', 'high']].apply(lambda x: np.clip(x[0], x[1], x[2]), axis=1)

        with self.assertRaises(ValueError):
            self.run_backtest_and_print(
                'test_negative_initial_balance',
                symbol='EURUSD',
                data=varied_data,
                initial_balance=-10000,
                risk_percent=0.01,
                min_take_profit=100,
                max_loss_per_day=100,
                starting_equity=10000,
                stop_loss_pips=20,
                pip_value=0.0001,
                max_trades_per_day=5
         )

    def test_zero_risk_percent(self):
        with self.assertRaises(ValueError):
            self.run_backtest_and_print(
                'test_zero_risk_percent',
                symbol='EURUSD',
                data=self.data,
                initial_balance=10000,
                risk_percent=0,
                min_take_profit=100,
                max_loss_per_day=100,
                starting_equity=10000,
                stop_loss_pips=20,
                pip_value=0.0001,
                max_trades_per_day=5
            )
    
    
    def generate_constant_dataset(self):
        # Generate data with slight fluctuations around a constant price
        constant_data = pd.DataFrame({
            'time': pd.date_range(start='2024-01-01', periods=200, freq='D'),
            'open': np.random.normal(loc=100, scale=0.1, size=200),
            'high': np.random.normal(loc=100, scale=0.1, size=200),
            'low': np.random.normal(loc=100, scale=0.1, size=200),
            'close': np.random.normal(loc=100, scale=0.1, size=200)
        })
        
        # Ensure 'high' is always greater than or equal to 'low'
        constant_data['high'] = constant_data[['high', 'low']].max(axis=1)
        constant_data['low'] = constant_data[['high', 'low']].min(axis=1)
        
        return constant_data

    def test_constant_prices(self):
        constant_data = self.generate_constant_dataset()
        
        result = self.run_backtest_and_print(
            'test_constant_prices',
            symbol='EURUSD',
            data=constant_data,
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=100,
            max_loss_per_day=100,
            starting_equity=10000,
            stop_loss_pips=20,
            pip_value=0.0001,
            max_trades_per_day=5
        )
        
        # Since prices are constant, we might expect no trades
        expected_trades = 0
        self.assertEqual(result['num_trades'], expected_trades, "Expected no trades in a constant price scenario")

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    unittest.main()

</document_content>
</document>

<document index="16">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\integration\__init__.py</source>
<document_content>

</document_content>
</document>

<document index="17">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\unit\backtesting\test_backtest.py</source>
<document_content>
# tests/backtesting/test_backtest.py
import unittest
from unittest.mock import patch, MagicMock
import pandas as pd
from backtesting.backtest import run_backtest, calculate_max_drawdown, calculate_position_size

class TestBacktest(unittest.TestCase):

    def setUp(self):
        # Create a mock historical data
        self.mock_data = pd.DataFrame({
            'time': pd.date_range(start='2023-01-01', periods=30, freq='H'),
            'open': [i + 1 for i in range(30)],
            'high': [i + 2 for i in range(30)],
            'low': [i for i in range(30)],
            'close': [i + 1.5 for i in range(30)],
            'tick_volume': [100 + i for i in range(30)],
            'spread': [1 for i in range(30)],
            'real_volume': [1000 + i for i in range(30)]
        })

    @patch('backtesting.backtest.get_historical_data')
    @patch('backtesting.backtest.generate_trade_signal', return_value='BUY')
    @patch('backtesting.backtest.execute_trade')
    @patch('backtesting.backtest.manage_position')
    def test_run_backtest(self, mock_manage_position, mock_execute_trade, mock_generate_trade_signal, mock_get_historical_data):
        # Mock the get_historical_data function to return the mock data
        mock_get_historical_data.return_value = self.mock_data

        run_backtest(
            symbol='EURUSD',
            initial_balance=10000,
            risk_percent=0.01,
            min_take_profit=50,
            max_loss_per_day=1000,
            starting_equity=10000,
            max_trades_per_day=5
        )

        mock_get_historical_data.assert_called_once()
        mock_generate_trade_signal.assert_called()
        mock_execute_trade.assert_called()
        mock_manage_position.assert_called()
    
    def test_calculate_max_drawdown(self):
        trades = [
            {'profit': 100},
            {'profit': -50},
            {'profit': 200},
            {'profit': -100}
        ]
        initial_balance = 1000
        max_drawdown = calculate_max_drawdown(trades, initial_balance)
        self.assertEqual(max_drawdown, 100)

    def test_calculate_position_size(self):
        account_balance = 10000
        risk_per_trade = 0.01
        stop_loss_pips = 50
        pip_value = 10
        expected_position_size = 0.2
        position_size = calculate_position_size(account_balance, risk_per_trade, stop_loss_pips, pip_value)
        self.assertEqual(position_size, expected_position_size)

if __name__ == '__main__':
    unittest.main()

</document_content>
</document>

<document index="18">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\unit\config\test_config.py</source>
<document_content>
import unittest
from unittest.mock import patch, MagicMock

class TestConfig(unittest.TestCase):

    @patch.dict('os.environ', {}, clear=True)
    def test_mt5_login_not_set(self):
        with self.assertRaises(ValueError) as context:
            from config import Config
            Config.MT5_LOGIN
        self.assertEqual(str(context.exception), "MT5_LOGIN environment variable is not set.")

    @patch.dict('os.environ', {'MT5_LOGIN': 'valid_value', 'MT5_PASSWORD': 'password', 'MT5_SERVER': 'server', 'MT5_PATH': 'path', 'MT5_TIMEFRAME': 'H1', 'SYMBOLS': 'EURUSD,GBPUSD'})
    def test_mt5_login_set(self):
        from config import Config
        self.assertEqual(Config.MT5_LOGIN, 'valid_value')

    @patch.dict('os.environ', {
        'MT5_LOGIN': 'login',
        'MT5_PASSWORD': 'password',
        'MT5_SERVER': 'server',
        'MT5_PATH': 'path',
        'MT5_TIMEFRAME': 'H1',
        'SYMBOLS': 'EURUSD,GBPUSD',
        'MIN_TP_PROFIT': '50.0',
        'MAX_LOSS_PER_DAY': '1000.0',
        'STARTING_EQUITY': '10000.0',
        'LIMIT_NO_OF_TRADES': '5',
        'RISK_PER_TRADE': '0.01',
        'PIP_VALUE': '1'
    })
    def test_valid_config(self):
        from config import Config
        Config.validate()

if __name__ == '__main__':
    unittest.main()


</document_content>
</document>

<document index="19">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\unit\metatrader\test_connection.py</source>
<document_content>
import unittest
from unittest.mock import patch
from metatrader.connection import initialize_mt5, shutdown_mt5

class TestConnection(unittest.TestCase):
    @patch('MetaTrader5.initialize', return_value=True)
    def test_initialize_mt5_success(self, mock_initialize):
        self.assertTrue(initialize_mt5('dummy_path'))

    @patch('MetaTrader5.initialize', return_value=False)
    def test_initialize_mt5_failure(self, mock_initialize):
        self.assertFalse(initialize_mt5('dummy_path'))

    @patch('MetaTrader5.shutdown')
    def test_shutdown_mt5(self, mock_shutdown):
        shutdown_mt5()
        mock_shutdown.assert_called_once()

    @patch('MetaTrader5.initialize')
    def test_initialize_mt5_exception(self, mock_initialize):
        mock_initialize.side_effect = Exception("Initialization failed")
        with self.assertRaises(Exception):
            initialize_mt5('dummy_path')

    @patch('MetaTrader5.initialize', return_value=True)
    def test_initialize_mt5_invalid_path(self, mock_initialize):
        invalid_path = ''
        self.assertFalse(initialize_mt5(invalid_path))
        
    @patch('MetaTrader5.shutdown')
    def test_shutdown_mt5_multiple_calls(self, mock_shutdown):
        shutdown_mt5()
        shutdown_mt5()
        self.assertEqual(mock_shutdown.call_count, 2)

if __name__ == '__main__':
    unittest.main()

</document_content>
</document>

<document index="20">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\unit\metatrader\test_data_retrieval.py</source>
<document_content>
import unittest
from unittest.mock import patch
from datetime import datetime
from metatrader.data_retrieval import get_historical_data
import MetaTrader5 as mt5
import pandas as pd

class TestDataRetrieval(unittest.TestCase):
    @patch('MetaTrader5.copy_rates_range', return_value=[
        {'time': 1633072800, 'open': 1.1600, 'high': 1.1700, 'low': 1.1500, 'close': 1.1650, 'tick_volume': 100, 'spread': 1, 'real_volume': 1000}
    ])
    def test_get_historical_data_valid_data(self, mock_copy_rates_range):
        symbol = "EURUSD"
        timeframe = mt5.TIMEFRAME_M1
        start_time = datetime(2023, 1, 1)
        end_time = datetime.now()
        data = get_historical_data(symbol, timeframe, start_time, end_time)
        self.assertIsInstance(data, pd.DataFrame)
        self.assertFalse(data.empty)
        self.assertIn('time', data.columns)
        self.assertIn('open', data.columns)

    @patch('MetaTrader5.copy_rates_range', return_value=[])
    def test_get_historical_data_empty(self, mock_copy_rates_range):
        symbol = "EURUSD"
        timeframe = mt5.TIMEFRAME_M1
        start_time = datetime(2023, 1, 1)
        end_time = datetime.now()
        data = get_historical_data(symbol, timeframe, start_time, end_time)
        self.assertIsNone(data)

    @patch('MetaTrader5.copy_rates_range', side_effect=Exception("MT5 error"))
    def test_get_historical_data_exception(self, mock_copy_rates_range):
        symbol = "EURUSD"
        timeframe = mt5.TIMEFRAME_M1
        start_time = datetime(2023, 1, 1)
        end_time = datetime.now()
        data = get_historical_data(symbol, timeframe, start_time, end_time)
        self.assertIsNone(data)

    @patch('MetaTrader5.copy_rates_range', return_value=None)
    def test_get_historical_data_none(self, mock_copy_rates_range):
        symbol = "INVALID_SYMBOL"
        timeframe = mt5.TIMEFRAME_M1
        start_time = datetime(2023, 1, 1)
        end_time = datetime.now()
        data = get_historical_data(symbol, timeframe, start_time, end_time)
        self.assertIsNone(data)

if __name__ == '__main__':
    unittest.main()

</document_content>
</document>

<document index="21">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\unit\metatrader\test_indicators.py</source>
<document_content>
import unittest
import numpy as np
import pandas as pd
from metatrader.indicators import calculate_ema

class TestIndicators(unittest.TestCase):
    def test_calculate_ema_list(self):
        data = [100, 200, 300, 400, 500]
        period = 3
        expected_ema = [np.nan, np.nan, 200.0, 300.0, 400.0]
        result = calculate_ema(data, period).tolist()
        np.testing.assert_array_almost_equal(result, expected_ema, decimal=5)

    def test_calculate_ema_numpy_array(self):
        data = np.array([100, 200, 300, 400, 500])
        period = 3
        expected_ema = [np.nan, np.nan, 200.0, 300.0, 400.0]
        result = calculate_ema(data, period).tolist()
        np.testing.assert_array_almost_equal(result, expected_ema, decimal=5)

    def test_calculate_ema_pandas_series(self):
        data = pd.Series([100, 200, 300, 400, 500])
        period = 3
        expected_ema = pd.Series([np.nan, np.nan, 200.0, 300.0, 400.0])
        result = calculate_ema(data, period)
        pd.testing.assert_series_equal(result, expected_ema)

    def test_calculate_ema_period_greater_than_length(self):
        data = [100, 200, 300]
        period = 5
        expected_ema = [np.nan, np.nan, np.nan]
        result = calculate_ema(data, period).tolist()
        np.testing.assert_array_almost_equal(result, expected_ema, decimal=5)

    def test_calculate_ema_empty_list(self):
        data = []
        period = 3
        expected_ema = []
        result = calculate_ema(data, period).tolist()
        self.assertEqual(result, expected_ema)

    def test_calculate_ema_invalid_input_type(self):
        data = "invalid input"
        period = 3
        with self.assertRaises(ValueError):
            calculate_ema(data, period)

if __name__ == '__main__':
    unittest.main()

</document_content>
</document>

<document index="22">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\unit\metatrader\test_trade_management.py</source>
<document_content>
import unittest
from unittest.mock import patch, MagicMock
from metatrader.trade_management import place_order, close_position, modify_order
import MetaTrader5 as mt5

class TestTradeManagement(unittest.TestCase):

    @patch('MetaTrader5.order_send', return_value=MagicMock(retcode=10009, comment="python script order"))  # 10009: SUCCESS
    @patch('MetaTrader5.symbol_info_tick', return_value=MagicMock(ask=1.2345, bid=1.2340))
    def test_place_order_success(self, mock_symbol_info_tick, mock_order_send):
        symbol = "EURUSD"
        order_type = "buy"
        volume = 0.1
        price = 1.2345
        sl = 1.2300
        tp = 1.2400
        result = place_order(symbol, order_type, volume, price, sl, tp)
        self.assertEqual(result, "python script order")

    @patch('MetaTrader5.order_send', return_value=MagicMock(retcode=10004, comment="Order failed"))  # 10004: ERROR
    @patch('MetaTrader5.symbol_info_tick', return_value=MagicMock(ask=1.2345, bid=1.2340))
    def test_place_order_failure(self, mock_symbol_info_tick, mock_order_send):
        symbol = "EURUSD"
        order_type = "buy"
        volume = 0.1
        price = 1.2345
        sl = 1.2300
        tp = 1.2400
        result = place_order(symbol, order_type, volume, price, sl, tp)
        self.assertEqual(result, "Order failed")

    @patch('MetaTrader5.order_send', side_effect=Exception("Network error"))
    @patch('MetaTrader5.symbol_info_tick', return_value=MagicMock(ask=1.2345, bid=1.2340))
    def test_place_order_exception(self, mock_symbol_info_tick, mock_order_send):
        symbol = "EURUSD"
        order_type = "buy"
        volume = 0.1
        result = place_order(symbol, order_type, volume)
        self.assertEqual(result, "Order failed")

    @patch('MetaTrader5.positions_get', return_value=[MagicMock(ticket=12345)])
    @patch('MetaTrader5.Close', return_value=MagicMock(comment="Close successful"))
    def test_close_position_success(self, mock_close, mock_positions_get):
        ticket = 12345
        result = close_position(ticket)
        self.assertEqual(result, "Close successful")

    @patch('MetaTrader5.positions_get', return_value=[])
    def test_close_position_failure(self, mock_positions_get):
        ticket = 12345
        result = close_position(ticket)
        self.assertEqual(result, "Position not found")

    @patch('MetaTrader5.order_check', return_value=MagicMock(type=mt5.ORDER_TYPE_BUY))  # 0: BUY
    @patch('MetaTrader5.order_send', return_value=MagicMock(comment="Modify successful"))
    def test_modify_order_success(self, mock_order_send, mock_order_check):
        ticket = 12345
        sl = 1.2300
        tp = 1.2400
        result = modify_order(ticket, sl, tp)
        self.assertEqual(result, "Modify successful")

    @patch('MetaTrader5.order_check', return_value=None)
    def test_modify_order_failure(self, mock_order_check):
        ticket = 12345
        sl = 1.2300
        tp = 1.2400
        result = modify_order(ticket, sl, tp)
        self.assertEqual(result, "Order not found")

    @patch('MetaTrader5.order_check', return_value=MagicMock(type=mt5.ORDER_TYPE_BUY))
    @patch('MetaTrader5.order_send', side_effect=Exception("Network error"))
    def test_modify_order_exception(self, mock_order_send, mock_order_check):
        ticket = 12345
        sl = 1.2300
        tp = 1.2400
        result = modify_order(ticket, sl, tp)
        self.assertEqual(result, "Modify failed")

if __name__ == '__main__':
    unittest.main()

</document_content>
</document>

<document index="23">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\unit\strategy\test_strategy.py</source>
<document_content>
import unittest
import pandas as pd
import numpy as np
from unittest import mock
from unittest.mock import MagicMock
from strategy.tunnel_strategy import (
    calculate_ema, calculate_tunnel_bounds, detect_peaks_and_dips, 
    check_entry_conditions, generate_trade_signal, run_strategy, execute_trade, manage_position, adjust_deviation_factor, calculate_position_size
)
import MetaTrader5 as mt5
from unittest.mock import Mock, patch

class TestStrategy(unittest.TestCase):

    def test_calculate_ema(self):
        print("Running test_calculate_ema")
        prices = pd.Series([100, 200, 300, 400, 500])
        period = 3
        result = calculate_ema(prices, period)
        expected_ema = pd.Series([None, None, 200.0, 300.0, 400.0])
        pd.testing.assert_series_equal(result, expected_ema, check_names=False)
    
    def test_calculate_ema_empty_series(self):
        print("Running test_calculate_ema_empty_series")
        prices = pd.Series([], dtype=float)
        period = 3
        expected_ema = pd.Series([], dtype=float)
        result = calculate_ema(prices, period)
        pd.testing.assert_series_equal(result, expected_ema, check_names=False)
    
    def test_calculate_ema_non_numeric(self):
        print("Running test_calculate_ema_non_numeric")
        prices = pd.Series(['abc', 'def', 'ghi'])
        period = 3
        result = calculate_ema(prices, period)
        expected_ema = pd.Series([np.nan] * len(prices))
        pd.testing.assert_series_equal(result, expected_ema, check_names=False)

    def test_calculate_ema_small_period(self):
        print("Running test_calculate_ema_small_period")
        prices = pd.Series([100, 200, 300])
        period = 1
        expected_ema = pd.Series([100.0, 200.0, 300.0])
        result = calculate_ema(prices, period)
        pd.testing.assert_series_equal(result, expected_ema, check_names=False)
    
    def test_calculate_ema_large_period(self):
        print("Running test_calculate_ema_large_period")
        prices = pd.Series(range(1, 51))
        period = 50
        expected_ema = pd.Series([np.nan] * 49 + [np.mean(range(1, 51))], dtype=float)
        result = calculate_ema(prices, period)
        pd.testing.assert_series_equal(result, expected_ema, check_names=False)

    def test_calculate_tunnel_bounds(self):
        print("Running test_calculate_tunnel_bounds")
        data = pd.DataFrame({'close': [100, 200, 300, 400, 500]})
        period = 3
        deviation_factor = 1.0
        expected_upper_bound = pd.Series([np.nan, np.nan, 300.0, 400.0, 500.0])
        expected_lower_bound = pd.Series([np.nan, np.nan, 100.0, 200.0, 300.0])
        upper_bound, lower_bound = calculate_tunnel_bounds(data, period, deviation_factor)
        pd.testing.assert_series_equal(upper_bound.round(2), expected_upper_bound, check_names=False)
        pd.testing.assert_series_equal(lower_bound.round(2), expected_lower_bound, check_names=False)

    def test_calculate_tunnel_bounds_missing_columns(self):
        print("Running test_calculate_tunnel_bounds_missing_columns")
        data = pd.DataFrame({'open': [100, 200, 300]})
        period = 3
        deviation_factor = 1.0
        with self.assertRaises(KeyError):  # Assumes that the function needs 'close' column
            calculate_tunnel_bounds(data, period, deviation_factor)

    def test_calculate_tunnel_bounds_insufficient_length(self):
        print("Running test_calculate_tunnel_bounds_insufficient_length")
        data = pd.DataFrame({'close': [100, 200]})
        period = 3
        deviation_factor = 1.0
        expected_upper_bound = pd.Series([np.nan, np.nan])
        expected_lower_bound = pd.Series([np.nan, np.nan])
        upper_bound, lower_bound = calculate_tunnel_bounds(data, period, deviation_factor)
        pd.testing.assert_series_equal(upper_bound, expected_upper_bound, check_names=False)
        pd.testing.assert_series_equal(lower_bound, expected_lower_bound, check_names=False)

    def test_detect_peaks_and_dips(self):
        print("Running test_detect_peaks_and_dips")
        data = {
            'high': [10, 12, 15, 14, 13, 17, 16, 19, 18, 17],
            'low': [8, 7, 6, 9, 8, 11, 10, 9, 12, 11]
        }
        df = pd.DataFrame(data)
        peak_type = 3
        expected_peaks = [15, 17, 19]
        expected_dips = [6, 8, 9]
        peaks, dips = detect_peaks_and_dips(df, peak_type)
        print(f"Detected peaks: {peaks}, Detected dips: {dips}")
        self.assertEqual(peaks, expected_peaks)
        self.assertEqual(dips, expected_dips)

    def test_detect_peaks_and_dips_non_numeric(self):
        print("Running test_detect_peaks_and_dips_non_numeric")
        data = pd.DataFrame({'high': ['ten', 'twelve'], 'low': ['eight', 'seven']})
        peak_type = 3
        with self.assertRaises(TypeError):
            detect_peaks_and_dips(data, peak_type)

    def test_check_entry_conditions_missing_data(self):
        print("Running test_check_entry_conditions_missing_data")
        row = pd.Series({
         'close': 350,
         # 'wavy_c' missing
         'wavy_h': 320,
         'wavy_l': 310,
         'tunnel1': 250,
         'tunnel2': 240
        })
        peaks = [350]
        dips = [150]
        symbol = 'EURUSD'
        with self.assertRaises(KeyError):
         check_entry_conditions(row, peaks, dips, symbol)

    def test_check_entry_conditions_incorrect_types(self):
        print("Running test_check_entry_conditions_incorrect_types")
        row = pd.Series({
            'close': 350,
            'wavy_c': 300,
            'wavy_h': 320,
            'wavy_l': 310,
            'tunnel1': 250,
            'tunnel2': 240
        })
        peaks = 'not a list'
        dips = 'also not a list'
        symbol = 'EURUSD'
        with self.assertRaises(TypeError):
            check_entry_conditions(row, peaks, dips, symbol)

    @mock.patch('strategy.tunnel_strategy.mt5')
    def test_check_entry_conditions(self, mock_mt5):
        print("Running test_check_entry_conditions")
        row = pd.Series({
            'close': 350,
            'wavy_c': 300,
            'wavy_h': 320,
            'wavy_l': 310,
            'tunnel1': 250,
            'tunnel2': 240
        })
        peaks = [350]
        dips = [150]
        symbol = 'EURUSD'
        mock_symbol_info = mock.Mock()
        mock_symbol_info.trade_tick_size = 0.01
        mock_mt5.symbol_info.return_value = mock_symbol_info

        buy_condition, sell_condition = check_entry_conditions(row, peaks, dips, symbol)
        self.assertTrue(buy_condition)
        self.assertFalse(sell_condition)

    def test_generate_trade_signal_buy(self):
        print("Running test_generate_trade_signal_buy")
        data = pd.DataFrame({'close': [100, 200, 300, 400, 500, 600]})
        period = 3
        deviation_factor = 1.0
        expected_signal = (True, False)

        signal = generate_trade_signal(data, period, deviation_factor)
        print(f"Expected: {expected_signal}, Got: {signal}")
        self.assertEqual(signal, expected_signal)

    def test_generate_trade_signal_sell(self):
        print("Running test_generate_trade_signal_sell")
        data = pd.DataFrame({'close': [100, 200, 300, 400, 500, 100]})  # Last close set to 100 to ensure 'SELL'
        period = 3
        deviation_factor = 1.0
        expected_signal = (False, True)

        signal = generate_trade_signal(data, period, deviation_factor)
        print(f"Expected: {expected_signal}, Got: {signal}")
        self.assertEqual(signal, expected_signal)

    def test_generate_trade_signal_none(self):
        print("Running test_generate_trade_signal_none")
        data = pd.DataFrame({'close': [100, 200, 300, 400, 500, 450]})
        period = 3
        deviation_factor = 1.0
        expected_signal = (False, False)

        signal = generate_trade_signal(data, period, deviation_factor)
        print(f"Expected: {expected_signal}, Got: {signal}")
        self.assertEqual(signal, expected_signal)
    
    def test_generate_trade_signal_non_numeric_data(self):
        print("Running test_generate_trade_signal_non_numeric_data")
        data = pd.DataFrame({
            'close': ['one', 'two', 'three', 4, 5, 6]
        })
        period = 3
        deviation_factor = 2
        expected_signal = (None, None)  # Since non-numeric data will be coerced to NaN, resulting in no valid signal
        result = generate_trade_signal(data, period, deviation_factor)
        self.assertEqual(result, expected_signal)

    def test_generate_trade_signal_small_dataset(self):
        print("Running test_generate_trade_signal_small_dataset")
        data = pd.DataFrame({'close': [100, 200]})
        period = 3
        deviation_factor = 1.0
        expected_signal = (None, None)  # Not enough data to generate a signal
        signal = generate_trade_signal(data, period, deviation_factor)
        self.assertEqual(signal, expected_signal)

    @mock.patch('strategy.tunnel_strategy.mt5')
    def test_run_strategy_initialization_failure(self, mock_mt5):
        print("Running test_run_strategy_initialization_failure")
        mock_mt5.initialize.return_value = False  # Simulate initialization failure
        symbols = ['EURUSD']
        timeframe = mock_mt5.TIMEFRAME_M1
        lot_size = 0.1
        min_take_profit = 10
        max_loss_per_day = 50
        starting_equity = 1000
        max_trades_per_day = 5
        with self.assertRaises(Exception):  # Assuming your function raises Exception on init failure
            run_strategy(symbols, mock_mt5.initialize, timeframe, lot_size, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day)

    @mock.patch('strategy.tunnel_strategy.mt5')
    def test_run_strategy_no_symbols_available(self, mock_mt5):
        print("Running test_run_strategy_no_symbols_available")
        mock_mt5.initialize.return_value = True
        mock_mt5.symbols_get.return_value = []  # No symbols returned
        symbols = ['EURUSD']
        timeframe = mock_mt5.TIMEFRAME_M1
        lot_size = 0.1
        min_take_profit = 10
        max_loss_per_day = 50
        starting_equity = 1000
        max_trades_per_day = 5
        with self.assertRaises(Exception) as context:
            run_strategy(symbols, mock_mt5.initialize, timeframe, lot_size, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day)
        self.assertIn("Failed to retrieve historical data for EURUSD", str(context.exception))

    @mock.patch('strategy.tunnel_strategy.mt5')
    @mock.patch('strategy.tunnel_strategy.get_historical_data')
    def test_run_strategy_data_to_signal_flow(self, mock_get_historical_data, mock_mt5):
        print("Running test_run_strategy_data_to_signal_flow")
        mock_mt5.initialize.return_value = True
        mock_mt5.symbols_get.return_value = [mock.Mock(name='EURUSD')]

        # Set up historical data with all required fields
        mock_get_historical_data.return_value = pd.DataFrame({
            'time': pd.date_range(start='1/1/2022', periods=5, freq='min'),
            'high': [110, 220, 330, 440, 550],
            'low': [90, 180, 270, 360, 450],
            'close': [105, 210, 315, 420, 525]
        })

        # Mock the additional required attributes/methods
        mock_mt5.symbol_info.return_value = mock.Mock()
        mock_mt5.symbol_info.return_value.trade_tick_size = 0.01  # Example value

        symbols = ['EURUSD']
        timeframe = mock_mt5.TIMEFRAME_M1
        lot_size = 0.1
        min_take_profit = 10
        max_loss_per_day = 50
        starting_equity = 1000
        max_trades_per_day = 5

        # Check to ensure strategy runs and captures the output or exceptions as expected
        try:
            result = run_strategy(symbols, mock_mt5.initialize, timeframe, lot_size, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day)
            print("Strategy ran successfully.")
        except Exception as e:
            print(f"Strategy failed with error: {str(e)}")

    @mock.patch('strategy.tunnel_strategy.mt5')
    @mock.patch('strategy.tunnel_strategy.get_historical_data')
    def test_run_strategy(self, mock_get_historical_data, mock_mt5):
        print("Running test_run_strategy")
        mock_mt5.TIMEFRAME_M1 = 1
        mock_mt5.symbol_info.return_value.trade_tick_size = 0.01
        
        symbols = ['EURUSD']
        timeframe = mock_mt5.TIMEFRAME_M1
        lot_size = 0.1
        min_take_profit = 10
        max_loss_per_day = 50
        starting_equity = 1000
        max_trades_per_day = 5

        # Mock data retrieval and other MT5 functions
        mock_mt5.initialize.return_value = True
        mock_mt5.symbols_get.return_value = [mock.Mock(name='EURUSD')]
        mock_get_historical_data.return_value = pd.DataFrame({
            'time': pd.date_range(start='1/1/2022', periods=5, freq='min'),
            'open': [100, 200, 300, 400, 500],
            'high': [110, 220, 330, 440, 550],
            'low': [90, 180, 270, 360, 450],
            'close': [105, 210, 315, 420, 525],
            'tick_volume': [1000, 2000, 3000, 4000, 5000],
            'spread': [10, 20, 30, 40, 50],
            'real_volume': [100, 200, 300, 400, 500]
        })

        run_strategy(symbols, mock_mt5.initialize, timeframe, lot_size, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day)
    
    @mock.patch('strategy.tunnel_strategy.place_order')
    def test_execute_trade_success(self, mock_place_order):
        print("Running test_execute_trade_success")
        mock_place_order.return_value = 'Order placed successfully'
        trade_request = {
            'symbol': 'EURUSD',
            'action': 'BUY',
            'volume': 1.0,
            'price': 1.2345,
            'sl': 1.2300,
            'tp': 1.2400
        }
        result = execute_trade(trade_request)
        self.assertEqual(result, 'Order placed successfully')
        # Adjusted to use positional arguments as shown in the actual call
        mock_place_order.assert_called_once_with(
            'EURUSD', 'buy', 1.0, 1.2345, 1.2300, 1.2400
        )
    
    @mock.patch('strategy.tunnel_strategy.place_order')
    def test_execute_trade_failure(self, mock_place_order):
        print("Running test_execute_trade_failure")
        mock_place_order.return_value = 'Order failed'  # Simulated failure message
        trade_request = {
            'symbol': 'EURUSD',
            'action': 'SELL',
            'volume': 1.0,
            'price': 1.2345,
            'sl': 1.2400,
            'tp': 1.2300
        }
        result = execute_trade(trade_request)
        self.assertIsNone(result)  # Checking if the result is None as expected
        mock_place_order.assert_called_once_with(
            'EURUSD',  # Ensure case and parameter order matches the actual call
            'sell', 
            1.0, 
            1.2345, 
            1.2400, 
            1.2300
        )
    
    @mock.patch('strategy.tunnel_strategy.place_order')
    @mock.patch('strategy.tunnel_strategy.handle_error')
    def test_execute_trade_exception(self, mock_handle_error, mock_place_order):
        print("Running test_execute_trade_exception")
        # Setup for exception scenario
        mock_place_order.side_effect = Exception("Connection error")
        trade_request = {
            'symbol': 'EURUSD',
            'action': 'BUY',
            'volume': 1.0,
            'price': 1.2345,
            'sl': 1.23,
            'tp': 1.24
        }

        result = execute_trade(trade_request)
        mock_place_order.assert_called_once_with(
        'EURUSD', 'buy', 1.0, 1.2345, 1.23, 1.24
        )
        self.assertIsNone(result)
        mock_handle_error.assert_called_once()

    
    @patch('strategy.tunnel_strategy.mt5')
    @patch('strategy.tunnel_strategy.close_position')
    def test_manage_position(self, mock_close_position, mock_mt5):
        print("Running test_manage_position")
        # Mock the positions_get and account_info responses
        mock_position1 = MagicMock(ticket=1, profit=500)
        mock_position2 = MagicMock(ticket=2, profit=-1500)
        mock_position3 = MagicMock(ticket=3, profit=0)
        mock_mt5.positions_get.return_value = [mock_position1, mock_position2, mock_position3]
        mock_mt5.account_info.return_value = MagicMock(equity=8000)
        mock_mt5.positions_total.return_value = 6  # Should close positions due to max trades exceeded

        # Mock the historical data retrieval
        mock_mt5.copy_rates_range.return_value = pd.DataFrame({
            'time': pd.date_range(start='2022-01-01', periods=5, freq='H'),
            'open': [1.1, 1.2, 1.3, 1.4, 1.5],
            'high': [1.15, 1.25, 1.35, 1.45, 1.55],
            'low': [1.05, 1.15, 1.25, 1.35, 1.45],
            'close': [1.1, 1.2, 1.3, 1.4, 1.5],
            'tick_volume': [100, 200, 300, 400, 500],
            'spread': [0, 0, 0, 0, 0],
            'real_volume': [0, 0, 0, 0, 0]
        })

        manage_position('EURUSD', min_take_profit=300, max_loss_per_day=1000, starting_equity=10000, max_trades_per_day=5)

        # Assertions for close_position calls
        mock_close_position.assert_any_call(1)  # Close position with profit > min_take_profit
        mock_close_position.assert_any_call(2)  # Close position with loss < -max_loss_per_day
        mock_close_position.assert_any_call(3)  # Close position due to equity drop
        self.assertEqual(mock_close_position.call_count, 3)  # Adjust expected call count

if __name__ == '__main__':
    unittest.main()


    def test_adjust_deviation_factor_volatile(self):
        print("Running test_adjust_deviation_factor_volatile")
        market_conditions = 'volatile'
        result = adjust_deviation_factor(market_conditions)
        self.assertEqual(result, 2.5)

    def test_adjust_deviation_factor_calm(self):
        print("Running test_adjust_deviation_factor_calm")
        market_conditions = 'calm'
        result = adjust_deviation_factor(market_conditions)
        self.assertEqual(result, 2.0)
    
    def test_calculate_position_size_valid_inputs(self):
        print("Running test_calculate_position_size_valid_inputs")
        account_balance = 10000
        risk_per_trade = 0.01
        stop_loss_pips = 50
        pip_value = 10

        expected_position_size = 0.2  # Corrected expected position size
        position_size = calculate_position_size(account_balance, risk_per_trade, stop_loss_pips, pip_value)
        self.assertEqual(position_size, expected_position_size)

if __name__ == '__main__':
    unittest.main()

</document_content>
</document>

<document index="24">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\unit\strategy\test_trade_logic.py</source>
<document_content>
import unittest
from unittest.mock import patch, Mock
from strategy.trade_logic import calculate_position_size, entry_long, entry_short, exit_trade
from utils.error_handling import handle_error

class TestStrategyFunctions(unittest.TestCase):

    def test_calculate_position_size_valid_inputs(self):
        print("Running test_calculate_position_size_valid_inputs")
        balance = 10000
        risk_percent = 0.01
        stop_loss_pips = 50
        pip_value = 10
        expected_position_size = 0.2
        result = calculate_position_size(balance, risk_percent, stop_loss_pips, pip_value)
        self.assertEqual(result, expected_position_size)

    def test_calculate_position_size_zero_stop_loss(self):
        print("Running test_calculate_position_size_zero_stop_loss")
        balance = 10000
        risk_percent = 0.01
        stop_loss_pips = 0
        pip_value = 10
        expected_position_size = 0
        result = calculate_position_size(balance, risk_percent, stop_loss_pips, pip_value)
        self.assertEqual(result, expected_position_size)

    def test_calculate_position_size_zero_pip_value(self):
        print("Running test_calculate_position_size_zero_pip_value")
        balance = 10000
        risk_percent = 0.01
        stop_loss_pips = 50
        pip_value = 0
        expected_position_size = 0
        result = calculate_position_size(balance, risk_percent, stop_loss_pips, pip_value)
        self.assertEqual(result, expected_position_size)

    @patch('strategy.trade_logic.execute_trade')
    def test_entry_long_success(self, mock_execute_trade):
        print("Running test_entry_long_success")
        mock_execute_trade.return_value = 'Order placed successfully'
        symbol = 'EURUSD'
        lot_size = 1.0
        price = 1.2345
        sl = 1.2300
        tp = 1.2400
        deviation = 10
        magic = 12345
        comment = 'Test Long Entry'
        result = entry_long(symbol, lot_size, price, sl, tp, deviation, magic, comment)
        self.assertEqual(result, 'Order placed successfully')
        mock_execute_trade.assert_called_once_with({
            'action': 'BUY',
            'symbol': symbol,
            'volume': lot_size,
            'price': price,
            'sl': sl,
            'tp': tp,
            'deviation': deviation,
            'magic': magic,
            'comment': comment,
            'type': 'ORDER_TYPE_BUY',
            'type_filling': 'ORDER_FILLING_FOK',
            'type_time': 'ORDER_TIME_GTC'
        })

    @patch('strategy.trade_logic.execute_trade')
    def test_entry_short_success(self, mock_execute_trade):
        print("Running test_entry_short_success")
        mock_execute_trade.return_value = 'Order placed successfully'
        symbol = 'EURUSD'

</document_content>
</document>

<document index="25">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\utils\test_data_validation.py</source>
<document_content>
import unittest
from unittest.mock import patch, MagicMock
from utils.data_validation import validate_data, sanitize_data, TradeRequestSchema, validate_trade_request
from pydantic import ValidationError

class TestDataValidation(unittest.TestCase):
    def setUp(self):
        self.valid_trade_request = {
            "action": "BUY",
            "symbol": "EURUSD",
            "volume": 0.1,
            "price": 1.2345,
            "sl": 1.2300,
            "tp": 1.2400,
            "deviation": 10,
            "magic": 12345,
            "comment": "Test order",
            "type": "ORDER_TYPE_BUY",
            "type_filling": "ORDER_FILLING_FOK",
            "type_time": "ORDER_TIME_GTC"
        }

    @patch('utils.data_validation.handle_error')
    def test_validate_data(self, mock_handle_error):
        self.assertTrue(validate_data(self.valid_trade_request, TradeRequestSchema))
        
    @patch('utils.data_validation.handle_error')
    def test_validate_data_invalid(self, mock_handle_error):
        invalid_data = self.valid_trade_request.copy()
        invalid_data.pop("action")
        self.assertFalse(validate_data(invalid_data, TradeRequestSchema))

    def test_sanitize_data(self):
        data = {
            "action": "  BUY  ",
            "symbol": "EURUSD",
            "volume": 0.1,
            "price": 1.2345,
            "sl": 1.2300,
            "tp": 1.2400
        }
        sanitized_data = sanitize_data(data)
        self.assertEqual(sanitized_data["action"], "BUY")

if __name__ == '__main__':
    unittest.main()

</document_content>
</document>

<document index="26">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\utils\test_error_handling.py</source>
<document_content>
import unittest
from unittest.mock import patch
from utils.error_handling import handle_error, critical_error, warn_error

class TestErrorHandling(unittest.TestCase):
    @patch('logging.error')
    def test_handle_error(self, mock_logging_error):
        error = ValueError("Test error")
        message = "An error occurred"
        handle_error(error, message)
        mock_logging_error.assert_called_with(f"{message}: {str(error)}")

    @patch('logging.critical')
    def test_critical_error(self, mock_logging_critical):
        error = ValueError("Test critical error")
        message = "A critical error occurred"
        with self.assertRaises(SystemExit):
            critical_error(error, message)
        mock_logging_critical.assert_called_with(f"{message}: {str(error)}")

    @patch('logging.warning')
    def test_warn_error(self, mock_logging_warning):
        error = ValueError("Test warning")
        message = "A warning occurred"
        warn_error(error, message)
        mock_logging_warning.assert_called_with(f"{message}: {str(error)}")

if __name__ == '__main__':
    unittest.main()
</document_content>
</document>

<document index="27">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\utils\test_logger.py</source>
<document_content>
import unittest
from unittest.mock import patch
from utils.logger import setup_logging

class TestLogger(unittest.TestCase):
    @patch('logging.basicConfig')
    def test_setup_logging(self, mock_logging_basicConfig):
        log_level = 20
        log_file = "test.log"
        setup_logging(log_level, log_file)
        mock_logging_basicConfig.assert_called_once()

if __name__ == '__main__':
    unittest.main()
</document_content>
</document>

<document index="28">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\utils\test_plotting.py</source>
<document_content>
import unittest
from unittest.mock import patch
from utils.plotting import plot_backtest_results

class TestPlotting(unittest.TestCase):
    @patch('matplotlib.pyplot.show')
    def test_plot_backtest_results(self, mock_pyplot_show):
        data = {
            'time': [1, 2, 3],
            'close': [100, 200, 300]
        }
        trades_with_balance = [
            {'entry_time': 1, 'entry_price': 100, 'exit_time': 2, 'exit_price': 200, 'balance': 1000},
            {'entry_time': 2, 'entry_price': 200, 'exit_time': 3, 'exit_price': 300, 'balance': 1100}
        ]
        trades_without_balance = [
            {'entry_time': 1, 'entry_price': 100, 'exit_time': 2, 'exit_price': 200},
            {'entry_time': 2, 'entry_price': 200, 'exit_time': 3, 'exit_price': 300}
        ]
        plot_backtest_results(data, trades_with_balance)
        plot_backtest_results(data, trades_without_balance)
        mock_pyplot_show.assert_called()

if __name__ == '__main__':
    unittest.main()

</document_content>
</document>

<document index="29">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\tests\utils\test_types.py</source>
<document_content>
import unittest
from utils.types import TradeAction, OrderType, OrderFilling, OrderTime, Symbol, Timeframe, LotSize

class TestTypes(unittest.TestCase):
    def test_trade_action(self):
        action = TradeAction("BUY")
        self.assertIsInstance(action, str)
        self.assertEqual(action, "BUY")

        with self.assertRaises(TypeError):
            TradeAction(123)  # Invalid type

    def test_order_type(self):
        order_type = OrderType("LIMIT")
        self.assertIsInstance(order_type, str)
        self.assertEqual(order_type, "LIMIT")

        with self.assertRaises(TypeError):
            OrderType(123)  # Invalid type

    def test_order_filling(self):
        filling = OrderFilling("FOK")
        self.assertIsInstance(filling, str)
        self.assertEqual(filling, "FOK")

        with self.assertRaises(TypeError):
            OrderFilling(123)  # Invalid type

    def test_order_time(self):
        order_time = OrderTime("GTC")
        self.assertIsInstance(order_time, str)
        self.assertEqual(order_time, "GTC")

        with self.assertRaises(TypeError):
            OrderTime(123)  # Invalid type

    def test_symbol(self):
        symbol = Symbol("EURUSD")
        self.assertIsInstance(symbol, str)
        self.assertEqual(symbol, "EURUSD")

        with self.assertRaises(TypeError):
            Symbol(123)  # Invalid type

    def test_timeframe(self):
        timeframe = Timeframe("M1")
        self.assertIsInstance(timeframe, str)
        self.assertEqual(timeframe, "M1")

        with self.assertRaises(TypeError):
            Timeframe(123)  # Invalid type

    def test_lot_size(self):
        lot_size = LotSize(1.0)
        self.assertIsInstance(lot_size, float)
        self.assertEqual(lot_size, 1.0)

        with self.assertRaises(TypeError):
            LotSize("1.0")  # Invalid type

if __name__ == '__main__':
    unittest.main()

</document_content>
</document>

<document index="30">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\utils\data_validation.py</source>
<document_content>
from typing import Any
from pydantic import BaseModel, ValidationError
import logging
from .error_handling import handle_error

class TradeRequestSchema(BaseModel):
    action: str
    symbol: str
    volume: float
    price: float
    sl: float
    tp: float
    deviation: int
    magic: int
    comment: str
    type: str
    type_filling: str
    type_time: str

class CloseRequestSchema(BaseModel):
    action: str
    position: int
    type: str
    type_filling: str
    type_time: str

def validate_data(data: Any, schema: BaseModel) -> bool:
    try:
        schema(**data)
        return True
    except ValidationError as e:
        handle_error(e, "Data validation failed")
        return False

def sanitize_data(data: Any) -> Any:
    try:
        if isinstance(data, dict):
            sanitized_data = {}
            for key, value in data.items():
                sanitized_data[key.strip()] = sanitize_data(value)
            return sanitized_data
        elif isinstance(data, list):
            return [sanitize_data(item) for item in data]
        elif isinstance(data, str):
            return data.strip()
        else:
            return data
    except Exception as e:
        handle_error(e, "Data sanitization failed")
        return None

def validate_trade_request(trade_request):
    required_fields = ['action', 'symbol', 'volume', 'price', 'sl', 'tp', 'deviation', 'magic', 'comment', 'type', 'type_filling', 'type_time']
    for field in required_fields:
        if field not in trade_request:
            raise ValueError(f"Missing required field: {field}")

    if trade_request['action'] not in ['BUY', 'SELL']:
        raise ValueError("Invalid trade action. Must be 'BUY' or 'SELL'")

    if trade_request['type'] not in ['ORDER_TYPE_BUY', 'ORDER_TYPE_SELL']:
        raise ValueError("Invalid order type. Must be 'ORDER_TYPE_BUY' or 'ORDER_TYPE_SELL'")

    if trade_request['type_filling'] != 'ORDER_FILLING_FOK':
        raise ValueError("Invalid order filling type. Must be 'ORDER_FILLING_FOK'")

    if trade_request['type_time'] != 'ORDER_TIME_GTC':
        raise ValueError("Invalid order time type. Must be 'ORDER_TIME_GTC'")

def validate_close_request(close_request):
    required_fields = ['action', 'position', 'type', 'type_filling', 'type_time']
    for field in required_fields:
        if field not in close_request:
            raise ValueError(f"Missing required field: {field}")

    if close_request['action'] != 'CLOSE':
        raise ValueError("Invalid close action. Must be 'CLOSE'")

    if close_request['type'] != 'ORDER_TYPE_CLOSE':
        raise ValueError("Invalid order type. Must be 'ORDER_TYPE_CLOSE'")

    if close_request['type_filling'] != 'ORDER_FILLING_FOK':
        raise ValueError("Invalid order filling type. Must be 'ORDER_FILLING_FOK'")

    if close_request['type_time'] != 'ORDER_TIME_GTC':
        raise ValueError("Invalid order time type. Must be 'ORDER_TIME_GTC'")

</document_content>
</document>

<document index="31">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\utils\error_handling.py</source>
<document_content>
import logging

def handle_error(error, message):
    logging.error(f"{message}: {str(error)}")

def critical_error(error, message):
    logging.critical(f"{message}: {str(error)}")
    raise SystemExit(1)

def warn_error(error, message):
    logging.warning(f"{message}: {str(error)}")

</document_content>
</document>

<document index="32">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\utils\logger.py</source>
<document_content>
import logging
import os

def setup_logging(log_level=logging.INFO, log_file="app.log"):
    """
    Set up logging configuration.
    """
    log_formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")

    file_handler = logging.FileHandler(log_file)
    file_handler.setFormatter(log_formatter)

    console_handler = logging.StreamHandler()
    console_handler.setFormatter(log_formatter)

    # Ensure no duplicate handlers
    for handler in logging.root.handlers[:]:
        logging.root.removeHandler(handler)

    logging.basicConfig(level=log_level, handlers=[file_handler, console_handler])

</document_content>
</document>

<document index="33">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\utils\plotting.py</source>
<document_content>
import matplotlib.pyplot as plt

def plot_backtest_results(data, trades):
    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8))

    # Plot price data
    ax1.plot(data['time'], data['close'], label='Price')
    ax1.set_ylabel('Price')
    ax1.set_title('Backtest Results')
    ax1.grid(True)

    # Plot trades
    for trade in trades:
        entry_time = trade['entry_time']
        entry_price = trade['entry_price']
        exit_time = trade.get('exit_time')
        exit_price = trade.get('exit_price')

        if exit_time is None:
            ax1.plot(entry_time, entry_price, 'g^', markersize=8, label='Entry')
        else:
            ax1.plot(entry_time, entry_price, 'g^', markersize=8)
            ax1.plot(exit_time, exit_price, 'rv', markersize=8)
            ax1.plot([entry_time, exit_time], [entry_price, exit_price], 'k--')

    ax1.legend()

    # Plot account balance
    balance = [trade.get('balance') for trade in trades if 'balance' in trade]
    # Adjust balance list to match the length of data['time']
    if len(balance) < len(data['time']):
        balance += [None] * (len(data['time']) - len(balance))

    ax2.plot(data['time'], balance, label='Account Balance')
    ax2.set_ylabel('Balance')
    ax2.set_title('Account Balance')
    ax2.grid(True)
    ax2.legend()

    plt.tight_layout()
    plt.show()

</document_content>
</document>

<document index="34">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\utils\types.py</source>
<document_content>
class TradeAction(str):
    def __new__(cls, value):
        if not isinstance(value, str):
            raise TypeError(f"TradeAction must be a string, got {type(value).__name__}")
        return str.__new__(cls, value)

class OrderType(str):
    def __new__(cls, value):
        if not isinstance(value, str):
            raise TypeError(f"OrderType must be a string, got {type(value).__name__}")
        return str.__new__(cls, value)

class OrderFilling(str):
    def __new__(cls, value):
        if not isinstance(value, str):
            raise TypeError(f"OrderFilling must be a string, got {type(value).__name__}")
        return str.__new__(cls, value)

class OrderTime(str):
    def __new__(cls, value):
        if not isinstance(value, str):
            raise TypeError(f"OrderTime must be a string, got {type(value).__name__}")
        return str.__new__(cls, value)

class Symbol(str):
    def __new__(cls, value):
        if not isinstance(value, str):
            raise TypeError(f"Symbol must be a string, got {type(value).__name__}")
        return str.__new__(cls, value)

class Timeframe(str):
    def __new__(cls, value):
        if not isinstance(value, str):
            raise TypeError(f"Timeframe must be a string, got {type(value).__name__}")
        return str.__new__(cls, value)

class LotSize(float):
    def __new__(cls, value):
        if not isinstance(value, (float, int)):
            raise TypeError(f"LotSize must be a float, got {type(value).__name__}")
        return float.__new__(cls, value)

</document_content>
</document>

<document index="35">
<source>C:\Users\Owner\Desktop\upwork_projects\Wavy_Tunnel_Bot\utils\__init__.py</source>
<document_content>
from .data_validation import validate_data, sanitize_data, validate_trade_request, validate_close_request
from .logger import setup_logging
from .types import TradeAction, OrderType, OrderFilling, OrderTime, Symbol, Timeframe, LotSize
</document_content>
</document>

</documents>