File: C:\Users\owner\Desktop\upwork_projects\trade_bot\wavy_tunnel_bot\config.py
----------------------------------------
import os
from dotenv import load_dotenv
from utils.error_handling import handle_error, critical_error
import logging
import MetaTrader5 as mt5
from datetime import datetime

# Load environment variables from the .env file
script_dir = os.path.dirname(os.path.abspath(__file__))
project_dir = os.path.dirname(script_dir)
dotenv_path = os.path.join(project_dir, '.env')

def reload_env():
    load_dotenv(dotenv_path, override=True)

reload_env()

class Config:
    # MetaTrader 5 Settings
    MT5_LOGIN = os.getenv("MT5_LOGIN")
    if not MT5_LOGIN:
        raise ValueError("MT5_LOGIN environment variable is not set.")

    MT5_PASSWORD = os.getenv("MT5_PASSWORD")
    if not MT5_PASSWORD:
        raise ValueError("MT5_PASSWORD environment variable is not set.")

    MT5_SERVER = os.getenv("MT5_SERVER")
    if not MT5_SERVER:
        raise ValueError("MT5_SERVER environment variable is not set.")

    MT5_PATH = os.getenv("MT5_PATH")
    if not MT5_PATH:
        raise ValueError("MT5_PATH environment variable is not set.")

    MT5_TIMEFRAME = os.getenv("MT5_TIMEFRAME")
    TIMEFRAME_DICT = {
        "M1": mt5.TIMEFRAME_M1,
        "M5": mt5.TIMEFRAME_M5,
        "M15": mt5.TIMEFRAME_M15,
        "M30": mt5.TIMEFRAME_M30,
        "H1": mt5.TIMEFRAME_H1,
        "H4": mt5.TIMEFRAME_H4,
        "D1": mt5.TIMEFRAME_D1
    }
    if MT5_TIMEFRAME not in TIMEFRAME_DICT:
        raise ValueError(f"Invalid MT5_TIMEFRAME value: {MT5_TIMEFRAME}. Expected values: M1, M5, M15, M30, H1, H4, D1.")
    MT5_TIMEFRAME_VALUE = TIMEFRAME_DICT[MT5_TIMEFRAME]

    SYMBOLS = os.getenv("SYMBOLS")
    if SYMBOLS:
        SYMBOLS = SYMBOLS.split(",")
    else:
        raise ValueError("SYMBOLS environment variable is not set.")

    # Telegram Bot Settings
    TELEGRAM_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
    TELEGRAM_IDS = os.getenv("TELEGRAM_IDS")
    if TELEGRAM_TOKEN and TELEGRAM_IDS:
        TELEGRAM_IDS = TELEGRAM_IDS.split(",")
    else:
        TELEGRAM_TOKEN = None
        TELEGRAM_IDS = None

    # Trading Strategy Settings
    try:
        MIN_TP_PROFIT = float(os.getenv("MIN_TP_PROFIT", 50.0))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid MIN_TP_PROFIT value: {os.getenv('MIN_TP_PROFIT')}. Expected a numeric value.")

    try:
        MAX_LOSS_PER_DAY = float(os.getenv("MAX_LOSS_PER_DAY", 1000.0))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid MAX_LOSS_PER_DAY value: {os.getenv('MAX_LOSS_PER_DAY')}. Expected a numeric value.")

    try:
        STARTING_EQUITY = float(os.getenv("STARTING_EQUITY", 10000.0))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid STARTING_EQUITY value: {os.getenv('STARTING_EQUITY')}. Expected a numeric value.")

    try:
        LIMIT_NO_OF_TRADES = int(os.getenv("LIMIT_NO_OF_TRADES", 5))
    except (ValueError, TypeError):
        raise ValueError(f"Invalid LIMIT_NO_OF_TRADES value: {os.getenv('LIMIT_NO_OF_TRADES')}. Expected an integer value.")

    try:
        RISK_PER_TRADE = float(os.getenv("RISK_PER_TRADE", 0.01))
    except ValueError:
        raise ValueError(f"Invalid RISK_PER_TRADE value: {os.getenv('RISK_PER_TRADE')}. Expected a numeric value.")
    if not 0 < RISK_PER_TRADE <= 1:
        raise ValueError(f"RISK_PER_TRADE value must be between 0 and 1. Current value: {RISK_PER_TRADE}")

    try:
        PIP_VALUE = float(os.getenv("PIP_VALUE", 1))
    except ValueError:
        raise ValueError(f"Invalid PIP_VALUE value: {os.getenv('PIP_VALUE')}. Expected a numeric value.")

    try:
        MAX_DRAWDOWN = float(os.getenv("MAX_DRAWDOWN", 0.2))
    except ValueError:
        raise ValueError(f"Invalid MAX_DRAWDOWN value: {os.getenv('MAX_DRAWDOWN')}. Expected a numeric value.")

    ENABLE_PENDING_ORDER_FALLBACK = os.getenv("ENABLE_PENDING_ORDER_FALLBACK", "True").lower() in ("true", "1", "yes")

    # SL/TP Adjustment
    SL_TP_ADJUSTMENT_PIPS = float(os.getenv("SL_TP_ADJUSTMENT_PIPS", 0.0001))

    # Optional Backtest Start/End Dates for Backtesting
    BACKTEST_START_DATE = os.getenv("BACKTEST_START_DATE")
    BACKTEST_END_DATE = os.getenv("BACKTEST_END_DATE")

    @classmethod
    def validate(cls):
        try:
            # Ensure all required environment variables are set
            required_vars = [
                'MT5_LOGIN', 'MT5_PASSWORD', 'MT5_SERVER', 'MT5_PATH',
                'MT5_TIMEFRAME', 'SYMBOLS'
            ]
            for var in required_vars:
                if not getattr(cls, var, None):
                    raise ValueError(f"Missing required environment variable: {var}")

            # Ensure all numeric variables have valid numeric values
            numeric_vars = ['MIN_TP_PROFIT', 'MAX_LOSS_PER_DAY', 'STARTING_EQUITY', 'RISK_PER_TRADE', 'PIP_VALUE', 'MAX_DRAWDOWN', 'SL_TP_ADJUSTMENT_PIPS']
            for var in numeric_vars:
                if not isinstance(getattr(cls, var, None), (int, float)):
                    raise ValueError(f"Invalid value for {var}. Expected a numeric value.")

            # Validate integer-specific configuration
            if not isinstance(cls.LIMIT_NO_OF_TRADES, int):
                raise ValueError(f"Invalid value for LIMIT_NO_OF_TRADES. Expected an integer value.")

            # Validate backtesting date configuration
            if cls.BACKTEST_START_DATE and cls.BACKTEST_END_DATE:
                try:
                    start_date = datetime.strptime(cls.BACKTEST_START_DATE, "%Y-%m-%d")
                    end_date = datetime.strptime(cls.BACKTEST_END_DATE, "%Y-%m-%d")
                    if start_date > end_date:
                        raise ValueError("BACKTEST_START_DATE must be earlier than BACKTEST_END_DATE.")
                    if end_date > datetime.now():
                        raise ValueError("BACKTEST_END_DATE cannot be in the future.")
                except ValueError as e:
                    raise ValueError(f"Invalid backtest date format: {str(e)}. Use YYYY-MM-DD format.")
            elif cls.BACKTEST_START_DATE or cls.BACKTEST_END_DATE:
                raise ValueError("Both BACKTEST_START_DATE and BACKTEST_END_DATE must be set for backtesting.")

        except ValueError as e:
            handle_error(e, "Configuration validation failed")
            critical_error(e, "Invalid configuration settings")

    @classmethod
    def log_config(cls):
        # Log all configuration settings for debugging purposes
        for attr, value in cls.__dict__.items():
            if not callable(value) and not attr.startswith("__") and not isinstance(value, classmethod):
                logging.info(f"{attr}: {value}")

# Validate configuration and log it
try:
    Config.validate()
    Config.log_config()
except Exception as e:
    handle_error(e, "Error occurred during configuration validation")
    raise

File: C:\Users\owner\Desktop\upwork_projects\trade_bot\wavy_tunnel_bot\main.py
----------------------------------------
import MetaTrader5 as mt5
import pandas as pd
from datetime import datetime
from config import Config
from metatrader.connection import initialize_mt5, shutdown_mt5
from strategy.tunnel_strategy import (
    check_broker_connection, check_market_open, execute_trade, place_pending_order, calculate_ema, detect_peaks_and_dips, check_entry_conditions, calculate_position_size, get_data
)
from backtesting.backtest import run_backtest
from utils.logger import setup_logging
from utils.error_handling import handle_error
from utils.mt5_log_checker import start_log_checking, stop_log_checking
import logging
import argparse
import os
import time

def clear_log_file():
    with open("app.log", "w"):
        pass

def check_auto_trading_enabled():
    """Check if global auto trading is enabled and log the status."""
    if not mt5.initialize():
        logging.error("Failed to initialize MetaTrader5 for checking auto trading status.")
        return False
    global_autotrading_enabled = mt5.terminal_info().trade_allowed
    if not global_autotrading_enabled:
        logging.error("Global auto trading is disabled. Please enable it manually in the MetaTrader 5 terminal.")
    else:
        logging.info("Global auto trading is enabled.")
    return global_autotrading_enabled

def validate_mt5_and_symbol(symbol):
    if not mt5.initialize():
        logging.error("Failed to initialize MT5 connection.")
        return False
    if not mt5.symbol_select(symbol, True):
        logging.error(f"Failed to select symbol {symbol}")
        return False
    return True

def log_mt5_version():
    if mt5.initialize():
        version = mt5.version()
        logging.info(f"MetaTrader5 version: {version}")
        mt5.shutdown()
    else:
        logging.error("Failed to initialize MT5 for version check.")

def get_account_info_with_retry(max_attempts=3, delay=2):
    for attempt in range(max_attempts):
        account_info = mt5.account_info()
        if account_info is not None:
            return account_info
        logging.warning(f"Failed to get account info. Attempt {attempt + 1} of {max_attempts}.")
        time.sleep(delay)
    return None

# def check_mt5_login():
#     if not mt5.login(login=Config.MT5_LOGIN, password=Config.MT5_PASSWORD, server=Config.MT5_SERVER):
#         error_code = mt5.last_error()
#         logging.error(f"Failed to login to MT5. Error code: {error_code}")
#         return False
#     return True

def wait_for_mt5_terminal_load(max_wait_time=30):
    start_time = time.time()
    while time.time() - start_time < max_wait_time:
        if mt5.terminal_info() is not None:
            return True
        time.sleep(1)
    return False

def run_backtest_func():
    try:
        logging.info("Initializing MetaTrader5...")
        if not initialize_mt5(Config.MT5_PATH):
            raise Exception("Failed to initialize MetaTrader5")
        logging.info("MetaTrader5 initialized successfully.")

        if not check_auto_trading_enabled():
            return

        for symbol in Config.SYMBOLS:
            if not validate_mt5_and_symbol(symbol):
                continue

            logging.info(f"Running backtest for {symbol}...")
            start_date = datetime.strptime(Config.BACKTEST_START_DATE, "%Y-%m-%d") if Config.BACKTEST_START_DATE else datetime(2023, 1, 1)
            end_date = datetime.strptime(Config.BACKTEST_END_DATE, "%Y-%m-%d") if Config.BACKTEST_END_DATE else datetime.now()
            initial_balance = 10000
            risk_percent = Config.RISK_PER_TRADE
            stop_loss_pips = 20
            pip_value = Config.PIP_VALUE

            backtest_data = get_data(symbol, mode='backtest', start_date=start_date, end_date=end_date, timeframe=Config.MT5_TIMEFRAME_VALUE)
            if backtest_data is not None and not backtest_data.empty:
                logging.info(f"Backtest data retrieved for {symbol}. Shape: {backtest_data.shape}")
                logging.info(f"Date range: from {backtest_data['time'].min()} to {backtest_data['time'].max()}")
                logging.info(f"Backtest data head:\n{backtest_data.head()}")
            else:
                logging.error(f"No historical data retrieved for {symbol} for backtesting. Timeframe: {Config.MT5_TIMEFRAME}, Start: {start_date}, End: {end_date}")
                continue

            if len(backtest_data) < 20:
                logging.error(f"Not enough data for symbol {symbol} to perform backtest")
                continue

            backtest_data.loc[:, 'close'] = pd.to_numeric(backtest_data['close'], errors='coerce')

            try:
                result = run_backtest(
                    symbol=symbol,
                    initial_balance=initial_balance,
                    risk_percent=risk_percent,
                    min_take_profit=Config.MIN_TP_PROFIT,
                    max_loss_per_day=Config.MAX_LOSS_PER_DAY,
                    starting_equity=Config.STARTING_EQUITY,
                    stop_loss_pips=stop_loss_pips,
                    pip_value=pip_value,
                    max_trades_per_day=Config.LIMIT_NO_OF_TRADES,
                    data=backtest_data,
                    start_date=start_date,
                    end_date=end_date
                )
                if result:
                    logging.info(f"Backtest results for {symbol}: {result}")
                else:
                    logging.warning(f"Backtest for {symbol} did not produce results.")
                logging.info(f"Backtest completed successfully for {symbol}.")
            except Exception as e:
                handle_error(e, f"An error occurred during backtesting for {symbol}")

    except Exception as e:
        error_code = mt5.last_error()
        error_message = str(e)
        handle_error(e, f"An error occurred in the run_backtest_func: {error_code} - {error_message}")

    finally:
        logging.info("Shutting down MetaTrader5...")
        shutdown_mt5()
        logging.info("MetaTrader5 connection gracefully shut down.")

def run_live_trading_func():
    try:
        logging.info("Initializing MetaTrader5...")
        if not initialize_mt5(Config.MT5_PATH):
            raise Exception("Failed to initialize MetaTrader5")
        logging.info("MetaTrader5 initialized successfully.")

        if not wait_for_mt5_terminal_load():
            raise Exception("MetaTrader5 terminal did not load within the expected time")

        # if not check_mt5_login():
        #     raise Exception("Failed to login to MetaTrader5")

        if not check_auto_trading_enabled():
            return

        account_info = get_account_info_with_retry()
        if account_info is None:
            error_code = mt5.last_error()
            error_desc = mt5.last_error_description()
            raise Exception(f"Failed to get account info. Error code: {error_code}, Description: {error_desc}")

        if account_info.server.endswith("demo"):
            logging.info("Trading on a demo account.")
        else:
            logging.info("Trading on a live account.")

        starting_balance = account_info.balance
        current_balance = starting_balance
        logging.info(f"Starting balance: {starting_balance:.2f}")

        if not check_broker_connection():
            return

        if not check_market_open():
            return

        daily_trades = 0
        total_trades = 0
        total_profit = 0.0
        total_loss = 0.0
        max_drawdown_reached = False

        start_time = time.time()
        max_duration = 1 * 1800  # 30 minutes for testing, adjust as needed
        last_log_time = time.time()

        while time.time() - start_time < max_duration:
            if max_drawdown_reached:
                logging.info("Maximum drawdown reached. Stopping trading.")
                break

            if time.time() - last_log_time > 300:  # Log every 5 minutes
                logging.info("Strategy still running...")
                last_log_time = time.time()

            current_day = datetime.now().date()
            if daily_trades >= Config.LIMIT_NO_OF_TRADES:
                logging.info("Maximum number of trades for the day reached. Stopping trading for today.")
                time.sleep(86400)
                daily_trades = 0
                continue

            for symbol in Config.SYMBOLS:
                if not validate_mt5_and_symbol(symbol):
                    continue

                logging.info(f"Processing symbol: {symbol}")

                live_data = get_data(symbol, mode='live', timeframe=Config.MT5_TIMEFRAME_VALUE)
                if live_data is None or live_data.empty:
                    logging.error(f"Failed to retrieve live data for {symbol}")
                    continue

                df = live_data

                logging.info(f"Dataframe created with tick data: {df.tail()}")

                if 'last' not in df.columns:
                    df['last'] = (df['bid'] + df['ask']) / 2
                    logging.info("'last' price calculated from 'bid' and 'ask'")

                df['close'] = df['last']
                if df['close'].eq(0).any():
                    df['close'] = (df['bid'] + df['ask']) / 2

                logging.info(f"Close price values: {df['close'].tail()}")

                if 'high' not in df.columns or 'low' not in df.columns:
                    df['high'] = df['ask']
                    df['low'] = df['bid']

                df['wavy_h'] = calculate_ema(df['high'], 34)
                df['wavy_c'] = calculate_ema(df['close'], 34)
                df['wavy_l'] = calculate_ema(df['low'], 34)
                df['tunnel1'] = calculate_ema(df['close'], 144)
                df['tunnel2'] = calculate_ema(df['close'], 169)
                df['long_term_ema'] = calculate_ema(df['close'], 200)

                logging.info(f"Indicator values for {symbol}:")
                logging.info(f"Wavy H: {df['wavy_h'].iloc[-1]:.5f}")
                logging.info(f"Wavy C: {df['wavy_c'].iloc[-1]:.5f}")
                logging.info(f"Wavy L: {df['wavy_l'].iloc[-1]:.5f}")
                logging.info(f"Tunnel1: {df['tunnel1'].iloc[-1]:.5f}")
                logging.info(f"Tunnel2: {df['tunnel2'].iloc[-1]:.5f}")
                logging.info(f"Long-term EMA: {df['long_term_ema'].iloc[-1]:.5f}")

                peaks, dips = detect_peaks_and_dips(df, 21)
                logging.info(f"Number of peaks detected: {len(peaks)}")
                logging.info(f"Number of dips detected: {len(dips)}")

                buy_condition, sell_condition = check_entry_conditions(df.iloc[-1], peaks, dips, symbol)
                logging.info(f"Entry conditions for {symbol}: Buy = {buy_condition}, Sell = {sell_condition}")

                std_dev = df['close'].rolling(window=20).std().iloc[-1]
                min_sl_tp_distance = 20 * Config.PIP_VALUE  # 20 pips minimum distance

                if buy_condition or sell_condition:
                    account_info = get_account_info_with_retry()
                    if account_info is None:
                        raise Exception("Failed to get account info")

                    balance_before = account_info.balance
                    logging.info(f"Account balance before trade attempt: {balance_before}")

                    current_price = df.iloc[-1]['ask'] if buy_condition else df.iloc[-1]['bid']
                    sl_distance = max(1.5 * std_dev, min_sl_tp_distance)
                    tp_distance = max(2 * std_dev, min_sl_tp_distance)

                    stop_loss_pips = sl_distance / Config.PIP_VALUE
                    volume = calculate_position_size(
                        account_balance=balance_before,
                        risk_per_trade=Config.RISK_PER_TRADE,
                        stop_loss_pips=stop_loss_pips,
                        pip_value=Config.PIP_VALUE
                    )

                    trade_request = {
                        'symbol': symbol,
                        'volume': volume,
                        'type': mt5.ORDER_TYPE_BUY if buy_condition else mt5.ORDER_TYPE_SELL,
                        'price': current_price,
                        'sl': current_price - sl_distance if buy_condition else current_price + sl_distance,
                        'tp': current_price + tp_distance if buy_condition else current_price - tp_distance,
                        'deviation': 10,
                        'magic': 12345,
                        'comment': 'Tunnel Strategy',
                        'type_filling': mt5.ORDER_FILLING_FOK,
                        'type_time': mt5.ORDER_TIME_GTC
                    }

                    logging.info(f"Placing order with the following details: {trade_request}")

                    try:
                        result = execute_trade(trade_request)
                        logging.info(f"Order send result: {result}")

                        if result is None:
                            logging.error("mt5.order_send returned None. This may indicate a silent failure or an internal error.")
                        elif result.retcode != mt5.TRADE_RETCODE_DONE:
                            logging.error(f"Order failed with retcode: {result.retcode}")

                            if Config.ENABLE_PENDING_ORDER_FALLBACK:
                                logging.info("Attempting to place a pending order due to market order failure...")
                                pending_order_result = place_pending_order(trade_request)
                                if pending_order_result is not None:
                                    logging.info("Pending order placed successfully.")
                                else:
                                    logging.error("Failed to place pending order.")
                        else:
                            logging.info("Order placed successfully.")

                            total_profit += result.profit if hasattr(result, 'profit') else 0.0
                            current_balance += result.profit if hasattr(result, 'profit') else 0.0

                            daily_trades += 1
                            total_trades += 1
                            logging.info(f"Live trading iteration completed for {symbol}. Total trades today: {daily_trades}")
                            logging.info(f"Current Balance: {current_balance:.2f}")

                    except Exception as e:
                        logging.error(f"An error occurred while running strategy for {symbol}: {e}")

                    account_info = get_account_info_with_retry()
                    if account_info is None:
                        raise Exception("Failed to get account info")

                    balance_after = account_info.balance
                    logging.info(f"Account balance after trade attempt: {balance_after}")
                    logging.info(f"Balance change: {balance_after - balance_before}")

                else:
                    logging.info(f"No trade conditions met for {symbol}")

                time.sleep(60)

            if time.time() - start_time >= max_duration:
                logging.info("Maximum duration reached. Stopping trading.")
                break

    except Exception as e:
        error_code = mt5.last_error()
        error_message = str(e)
        handle_error(e, f"An error occurred in the run_live_trading_func: {error_code} - {error_message}")

    finally:
        logging.info("Shutting down MetaTrader5...")
        shutdown_mt5()
        logging.info("MetaTrader5 connection gracefully shut down.")

        try:
            account_info = get_account_info_with_retry()
            if account_info is None:
                logging.error("Failed to get final account info")
                ending_balance = current_balance
            else:
                ending_balance = account_info.balance

            logging.info("Summary of Trading Session:")
            logging.info(f"Total trades: {total_trades}")
            logging.info(f"Starting balance: {starting_balance:.2f}")
            logging.info(f"Ending balance: {ending_balance:.2f}")
            logging.info(f"Total profit/loss: {ending_balance - starting_balance:.2f}")
        except Exception as e:
            logging.error(f"Error in finalizing trading session: {str(e)}")

def open_log_file():
    import subprocess
    log_file_path = os.path.abspath("app.log")
    if os.name == "nt":
        os.startfile(log_file_path)
    elif os.name == "posix":
        subprocess.call(["open", log_file_path])

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--ui", action="store_true", help="Run the UI")
    args = parser.parse_args()

    try:
        setup_logging()
        logging.info("STARTING APPLICATION")
        log_mt5_version()

        logging.info("LOGGING ALL THE CONFIG SETTINGS")
        Config.log_config()

        start_log_checking()

        if args.ui:
            run_ui(run_backtest_func, run_live_trading_func, clear_log_file, open_log_file)
        else:
            print("Choose an option:")
            print("1. Run Backtesting")
            print("2. Run Live Trading")
            choice = input("Enter your choice (1 or 2): ")

            if choice == "1":
                logging.info("User selected Backtesting")
                run_backtest_func()
            elif choice == "2":
                logging.info("User selected Live Trading")
                run_live_trading_func()
            else:
                logging.warning(f"Invalid choice entered: {choice}")
                print("Invalid choice. Exiting...")

    except Exception as e:
        error_code = mt5.last_error()
        error_message = str(e)
        handle_error(e, f"An error occurred in the main function: {error_code} - {error_message}. Timeframe: {Config.MT5_TIMEFRAME_VALUE}")

    finally:
        stop_log_checking()

if __name__ == '__main__':
    main()

File: C:\Users\owner\Desktop\upwork_projects\trade_bot\wavy_tunnel_bot\backtesting\backtest.py
----------------------------------------
import logging
import pandas as pd
import numpy as np
import pstats
from io import StringIO
from strategy.tunnel_strategy import generate_trade_signal, calculate_position_size, detect_peaks_and_dips, manage_position, check_entry_conditions, get_data
from metatrader.indicators import calculate_ema
from metatrader.trade_management import execute_trade
import cProfile
import MetaTrader5 as mt5


# Initialize the logger
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

def run_backtest(symbol, initial_balance, risk_percent, min_take_profit, max_loss_per_day, starting_equity, stop_loss_pips, pip_value, start_date=None, end_date=None, timeframe=mt5.TIMEFRAME_H1, max_trades_per_day=None, slippage=0, transaction_cost=0, enable_profiling=False, data=None):
    """
    Run a backtest for a given symbol with historical data.
    """
    # Initialize the profiler if profiling is enabled
    pr = cProfile.Profile() if enable_profiling else None
    if enable_profiling:
        pr.enable()

    # Check for zero or negative initial balance
    if initial_balance <= 0:
        raise ValueError("Initial balance must be greater than zero.")

    # Check for zero risk percentage
    if risk_percent == 0:
        raise ValueError("Risk percentage cannot be zero.")

    try:
        balance = initial_balance
        trades = []
        trades_today = 0
        peak_type = 21

        # Use provided data if available, otherwise fetch it
        if data is None:
            if start_date is None or end_date is None:
                raise ValueError("start_date and end_date must be provided if data is not supplied")
            data = get_data(symbol, mode='backtest', start_date=start_date, end_date=end_date, timeframe=timeframe)
        else:
            # If data is provided, extract start_date and end_date from it
            start_date = data['time'].min()
            end_date = data['time'].max()

        if data is None or data.empty:
            logger.error(f"No historical data available for {symbol}")
            return None

        current_day = data.iloc[0]['time'].date()

        data = data.copy()  # Make a copy to avoid modifying the original DataFrame

        # Handle missing values by interpolation
        data['high'] = data['high'].interpolate(method='linear')
        data['close'] = data['close'].interpolate(method='linear')
        data['low'] = data['low'].interpolate(method='linear')

        # Check if the DataFrame has enough rows for EMA calculation
        if len(data) < 200:
            raise ValueError("Not enough data to calculate required EMAs. Ensure data has at least 200 rows.")

        # Log the data length before EMA calculation
        logger.debug(f"Data length for 'high': {len(data['high'])}, 'low': {len(data['low'])}, 'close': {len(data['close'])}")

        # Calculate EMAs
        data.loc[:, 'wavy_h'] = calculate_ema(data['high'], 34)
        data.loc[:, 'wavy_c'] = calculate_ema(data['close'], 34)
        data.loc[:, 'wavy_l'] = calculate_ema(data['low'], 34)
        data.loc[:, 'tunnel1'] = calculate_ema(data['close'], 144)
        data.loc[:, 'tunnel2'] = calculate_ema(data['close'], 169)
        data.loc[:, 'long_term_ema'] = calculate_ema(data['close'], 200)

        # Peak and Dip detection
        peaks, dips = detect_peaks_and_dips(data, peak_type)

        # Loop through the data
        for i in range(34, len(data)):
            row = data.iloc[i]
            if row['time'].date() != current_day:
                current_day = row['time'].date()
                trades_today = 0
                logger.info(f"New trading day: {current_day}, resetting daily counters.")

            if max_trades_per_day is not None and trades_today >= max_trades_per_day:
                logger.info(f"Reached max trades per day: {max_trades_per_day}, skipping further trades for {current_day}.")
                continue

            buy_condition, sell_condition = check_entry_conditions(row, peaks, dips, symbol)

            if buy_condition is None or sell_condition is None:
                logger.debug(f"No trade signal generated for {row['time']}.")
                continue

            try:
                position_size = calculate_position_size(balance, risk_percent, stop_loss_pips, pip_value)
            except ZeroDivisionError as e:
                logger.warning(f"Zero division error while calculating position size: {e}")
                continue

            std_dev = data['close'].rolling(window=20).std().iloc[i]

            if buy_condition and (max_trades_per_day is None or trades_today < max_trades_per_day):
                trade = {
                    'entry_time': row['time'],
                    'entry_price': row['close'],
                    'volume': position_size,
                    'symbol': symbol,
                    'action': 'BUY',
                    'sl': row['close'] - (1.5 * std_dev),
                    'tp': row['close'] + (2 * std_dev),
                    'profit': 0  # Initialize profit to 0
                }
                execute_trade(trade)
                trades.append(trade)
                trades_today += 1
                logger.info(f"Executed BUY trade at {trade['entry_time']}, price: {trade['entry_price']}, volume: {trade['volume']}.")

            elif sell_condition and (max_trades_per_day is None or trades_today < max_trades_per_day):
                trade = {
                    'entry_time': row['time'],
                    'entry_price': row['close'],
                    'volume': position_size,
                    'symbol': symbol,
                    'action': 'SELL',
                    'sl': row['close'] + (1.5 * std_dev),
                    'tp': row['close'] - (2 * std_dev),
                    'profit': 0  # Initialize profit to 0
                }
                execute_trade(trade)
                trades.append(trade)
                trades_today += 1
                logger.info(f"Executed SELL trade at {trade['entry_time']}, price: {trade['entry_price']}, volume: {trade['volume']}.")

            manage_position(symbol, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day)

        # Calculate profits/losses for each trade
        for trade in trades:
            exit_price = trade['tp'] if trade['action'] == 'BUY' else trade['sl']
            if trade['action'] == 'BUY':
                trade['profit'] = (exit_price - trade['entry_price']) * trade['volume'] - slippage - transaction_cost
            else:
                trade['profit'] = (trade['entry_price'] - exit_price) * trade['volume'] - slippage - transaction_cost
            logger.info(f"Trade closed at {trade['entry_time']}, action: {trade['action']}, profit: {trade['profit']}.")

        total_profit = sum(trade.get('profit', 0) for trade in trades)
        num_trades = len(trades)
        win_rate = sum(1 for trade in trades if trade.get('profit', 0) > 0) / num_trades if num_trades > 0 else 0
        max_drawdown = calculate_max_drawdown(trades, initial_balance)

        final_balance = balance + total_profit

        logger.info(f"Backtest completed. Total Profit: {total_profit}, Final Balance: {final_balance}, Number of Trades: {num_trades}, Win Rate: {win_rate}, Max Drawdown: {max_drawdown}.")

        return {
            'total_profit': total_profit,
            'final_balance': final_balance,
            'num_trades': num_trades,
            'win_rate': win_rate,
            'max_drawdown': max_drawdown,
            'buy_condition': buy_condition,
            'sell_condition': sell_condition,
            'trades': trades,
            'total_slippage_costs': len(trades) * slippage,
            'total_transaction_costs': len(trades) * transaction_cost
        }

    finally:
        if enable_profiling and pr:
            pr.disable()
            s = StringIO()
            ps = pstats.Stats(pr, stream=s).sort_stats(pstats.SortKey.CUMULATIVE)
            ps.print_stats()
            print(s.getvalue())

def calculate_max_drawdown(trades, initial_balance):
    balance = initial_balance
    max_balance = initial_balance
    max_drawdown = 0

    for trade in trades:
        if 'profit' in trade:
            balance += trade['profit']
            max_balance = max(max_balance, balance)
            drawdown = max_balance - balance
            max_drawdown = max(max_drawdown, drawdown)

    return max_drawdown

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)

File: C:\Users\owner\Desktop\upwork_projects\trade_bot\wavy_tunnel_bot\strategy\tunnel_strategy.py
----------------------------------------
import pandas as pd
import numpy as np
import logging
import MetaTrader5 as mt5
from datetime import datetime, time as dtime
from utils.error_handling import handle_error
import time
from config import Config
from metatrader.data_retrieval import get_historical_data


logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

def get_current_data(symbol):
    tick = mt5.symbol_info_tick(symbol)
    if tick:
        tick_data = {
            'time': datetime.fromtimestamp(tick.time),
            'bid': tick.bid,
            'ask': tick.ask,
            'last': tick.last,
            'spread': tick.ask - tick.bid,
            'volume': tick.volume
        }
        logging.info(f"Retrieved tick data for {symbol}: {tick_data}")
        return tick_data
    else:
        raise ValueError(f"Failed to retrieve current tick data for {symbol}")

def calculate_ema(prices, period):
    logging.debug(f"Calculating EMA for period {period}")
    logging.debug(f"First few prices: {prices.head() if isinstance(prices, pd.Series) else prices[:5]}")

    prices = pd.Series(prices)
    prices = pd.to_numeric(prices, errors='coerce')
    ema_values = np.full(len(prices), np.nan, dtype=np.float64)
    if len(prices) < period:
        logging.warning(f"Not enough data for EMA calculation. Required: {period}, Available: {len(prices)}")
        return pd.Series(ema_values, index=prices.index)

    sma = np.mean(prices[:period])
    ema_values[period - 1] = sma
    multiplier = 2 / (period + 1)
    for i in range(period, len(prices)):
        ema_values[i] = (prices[i] - ema_values[i - 1]) * multiplier + ema_values[i - 1]

    result = pd.Series(ema_values, index=prices.index)
    logging.debug(f"Calculated EMA. Last few values: {result.tail()}")
    return result

def detect_peaks_and_dips(df, peak_type=5):
    logging.debug(f"Detecting peaks and dips with peak_type: {peak_type}")
    highs = df['high'].values
    lows = df['low'].values
    center_index = peak_type // 2
    peaks = []
    dips = []

    for i in range(center_index, len(highs) - center_index):
        peak_window = highs[i - center_index:i + center_index + 1]
        dip_window = lows[i - center_index:i + center_index + 1]

        logging.debug(f"Analyzing peak window: {peak_window}")
        logging.debug(f"Analyzing dip window: {dip_window}")

        if all(peak_window[center_index] > peak_window[j] for j in range(len(peak_window)) if j != center_index):
            peaks.append(highs[i])
            logging.debug(f"Peak detected at index {i}: {highs[i]}")

        if all(dip_window[center_index] < dip_window[j] for j in range(len(dip_window)) if j != center_index):
            dips.append(lows[i])
            logging.debug(f"Dip detected at index {i}: {lows[i]}")

    logging.info(f"Total peaks detected: {len(peaks)}, Peaks: {peaks}")
    logging.info(f"Total dips detected: {len(dips)}, Dips: {dips}")
    return peaks, dips

def check_entry_conditions(row, peaks, dips, symbol):
    wavy_c, wavy_h, wavy_l = row['wavy_c'], row['wavy_h'], row['wavy_l']
    tunnel1, tunnel2 = row['tunnel1'], row['tunnel2']
    close_price = row['close']

    logging.info(f"Checking entry conditions for {symbol}:")
    logging.info(f"Close price: {close_price:.5f}")
    logging.info(f"Wavy C: {wavy_c:.5f}, Wavy H: {wavy_h:.5f}, Wavy L: {wavy_l:.5f}")
    logging.info(f"Tunnel1: {tunnel1:.5f}, Tunnel2: {tunnel2:.5f}")

    logging.debug(f"Number of peaks detected: {len(peaks)}, Peaks (first 5): {peaks[:5]}")
    logging.debug(f"Number of dips detected: {len(dips)}, Dips (first 5): {dips[:5]}")

    buy_condition1 = close_price > max(wavy_c, wavy_h, wavy_l)
    buy_condition2 = min(wavy_c, wavy_h, wavy_l) > max(tunnel1, tunnel2)
    buy_condition3 = any(abs(close_price - peak) <= 0.001 for peak in peaks)
    logging.debug(f"Buy Condition 1 (close > max(Wavy C, Wavy H, Wavy L)): {buy_condition1}")
    logging.debug(f"Buy Condition 2 (min(Wavy C, Wavy H, Wavy L) > max(Tunnel1, Tunnel2)): {buy_condition2}")
    logging.debug(f"Buy Condition 3 (close price near peak): {buy_condition3}")
    sell_condition1 = close_price < min(wavy_c, wavy_h, wavy_l)
    sell_condition2 = max(wavy_c, wavy_h, wavy_l) < min(tunnel1, tunnel2)
    sell_condition3 = any(abs(close_price - dip) <= 0.001 for dip in dips)
    logging.debug(f"Sell Condition 1 (close < min(Wavy C, Wavy H, Wavy L)): {sell_condition1}")
    logging.debug(f"Sell Condition 2 (max(Wavy C, Wavy H, Wavy L) < min(Tunnel1, Tunnel2)): {sell_condition2}")
    logging.debug(f"Sell Condition 3 (close price near dip): {sell_condition3}")

    buy_condition = buy_condition1 or buy_condition2 or buy_condition3
    sell_condition = sell_condition1 or sell_condition2 or sell_condition3

  # Log the final conditions
    logging.info(f"Buy conditions: {buy_condition1}, {buy_condition2}, {buy_condition3}")
    logging.info(f"Sell conditions: {sell_condition1}, {sell_condition2}, {sell_condition3}")
    logging.info(f"Buy condition met: {buy_condition}")
    logging.info(f"Sell condition met: {sell_condition}")

    buy_reasons = [f"Condition {i+1}: {cond}" for i, cond in enumerate([buy_condition1, buy_condition2, buy_condition3]) if cond]
    sell_reasons = [f"Condition {i+1}: {cond}" for i, cond in enumerate([sell_condition1, sell_condition2, sell_condition3]) if cond]

    logging.info(f"Entry conditions for {symbol}: Buy = {buy_condition} (reasons: {', '.join(buy_reasons)}), Sell = {sell_condition} (reasons: {', '.join(sell_reasons)})")

    return buy_condition, sell_condition


def execute_trade(trade_request, retries=4, delay=6):
    attempt = 0
    while attempt <= retries:
        try:
            logging.info(f"Attempting to execute trade: {trade_request}")

            if not ensure_symbol_subscription(trade_request['symbol']):
                logging.error(f"Failed to subscribe to symbol {trade_request['symbol']}")
                return None

            if not check_broker_connection() or not check_market_open():
                logging.error("Trade execution aborted due to connection issues or market being closed.")
                return None

            modified_request = trade_request.copy()
            modified_request['action'] = mt5.TRADE_ACTION_DEAL

            # Log the SL and TP values before sending the order
            logging.info(f"Setting SL: {modified_request['sl']}, TP: {modified_request['tp']} before sending order.")
            logging.info(f"Placing order with price: {modified_request['price']} and volume: {modified_request['volume']}")

            result = mt5.order_send(modified_request)

            if result is None:
                error_code = mt5.last_error()
                logging.error(f"Failed to place order: mt5.order_send returned None. Error code: {error_code}")
                raise ValueError(f"mt5.order_send returned None. Error code: {error_code}")

            logging.info(f"Order response received at {datetime.now()}: {result}")

            if result.retcode == mt5.TRADE_RETCODE_DONE:
                logging.info(f"Trade executed successfully: {result}")
                return result
            elif result.retcode == 10009:
                logging.warning("Order placed successfully, but not yet executed")
                return result
            elif result.retcode == 10004:  # Requote
                logging.warning("Requote error. Retrying with updated price.")
                current_price = mt5.symbol_info_tick(trade_request['symbol']).ask if trade_request['type'] == mt5.ORDER_TYPE_BUY else mt5.symbol_info_tick(trade_request['symbol']).bid
                modified_request['price'] = current_price
                continue
            elif result.retcode == 10016:  # Invalid stops
                logging.error("Invalid stops. Adjusting SL and TP.")
                symbol_info = mt5.symbol_info(trade_request['symbol'])
                min_stop_level = symbol_info.trade_stops_level * symbol_info.point
                if trade_request['type'] == mt5.ORDER_TYPE_BUY:
                    modified_request['sl'] = min(modified_request['sl'], modified_request['price'] - min_stop_level)
                    modified_request['tp'] = max(modified_request['tp'], modified_request['price'] + min_stop_level)
                else:
                    modified_request['sl'] = max(modified_request['sl'], modified_request['price'] + min_stop_level)
                    modified_request['tp'] = min(modified_request['tp'], modified_request['price'] - min_stop_level)
                continue
            else:
                logging.error(f"Order failed with retcode: {result.retcode}, Comment: {result.comment}")
                raise ValueError(f"Order failed: {result.comment}")

        except Exception as e:
            logging.error(f"Exception occurred during trade execution attempt {attempt + 1}: {str(e)}")
            attempt += 1

        if attempt <= retries:
            logging.info(f"Retrying in {delay} seconds... Current attempt: {attempt}/{retries}")
            time.sleep(delay)

    logging.error("Trade execution failed after maximum retries.")
    return None

def place_pending_order(trade_request):
    try:
        order_type = mt5.ORDER_TYPE_BUY_LIMIT if trade_request['action'] == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_SELL_LIMIT
        adjusted_sl = trade_request['sl'] - Config.SL_TP_ADJUSTMENT_PIPS if trade_request['action'] == mt5.ORDER_TYPE_BUY else trade_request['sl'] + Config.SL_TP_ADJUSTMENT_PIPS
        adjusted_tp = trade_request['tp'] + Config.SL_TP_ADJUSTMENT_PIPS if trade_request['action'] == mt5.ORDER_TYPE_BUY else trade_request['tp'] - Config.SL_TP_ADJUSTMENT_PIPS

        pending_order_request = {
            "action": mt5.TRADE_ACTION_PENDING,
            "symbol": trade_request['symbol'],
            "volume": trade_request['volume'],
            "type": order_type,
            "price": trade_request['price'],
            "sl": adjusted_sl,
            "tp": adjusted_tp,
            "deviation": trade_request['deviation'],
            "magic": trade_request['magic'],
            "comment": f"Pending {trade_request['comment']}",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_RETURN,
        }

        logging.debug(f"Placing pending order: {pending_order_request}")
        result = mt5.order_send(pending_order_request)
        logging.info(f"Pending order result: {result}")

        if result.retcode != mt5.TRADE_RETCODE_DONE:
            logging.error(f"Failed to place pending order for {trade_request['symbol']}: {result.comment}")
            return None
        logging.info(f"Pending order placed successfully for {trade_request['symbol']}")
        return result
    except Exception as e:
        handle_error(e, "Failed to place pending order")
        return None

def manage_position(symbol, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day):
    try:
        positions = mt5.positions_get(symbol=symbol)
        if positions:
            for position in positions:
                current_equity = mt5.account_info().equity
                logging.info(f"Managing position for {symbol}. Current profit: {position.profit}, Equity: {current_equity}")

                if position.profit >= min_take_profit:
                    logging.info(f"Profit target reached for {symbol}. Closing position.")
                    close_result = close_position(position.ticket)
                    logging.info(f"Close position result: {close_result}")

                elif position.profit <= -max_loss_per_day:
                    logging.info(f"Loss limit reached for {symbol}. Closing position.")
                    close_result = close_position(position.ticket)
                    logging.info(f"Close position result: {close_result}")

                elif current_equity <= starting_equity * 0.9:
                    logging.info(f"Drawdown limit reached for {symbol}. Closing position.")
                    close_result = close_position(position.ticket)
                    logging.info(f"Close position result: {close_result}")

                elif mt5.positions_total() >= max_trades_per_day:
                    logging.info(f"Trade limit reached for the day. Closing position for {symbol}.")
                    close_result = close_position(position.ticket)
                    logging.info(f"Close position result: {close_result}")

                # Log the profit and details of the closed position
                position['exit_time'] = pd.Timestamp.now()
                position['exit_price'] = mt5.symbol_info_tick(symbol).bid
                position['profit'] = (position['exit_price'] - position['entry_price']) * position['volume']
                logging.info(f"Position details - Exit Time: {position['exit_time']}, Exit Price: {position['exit_price']}, Profit: {position['profit']}")

        else:
            logging.info(f"No open positions found for {symbol}.")
    except Exception as e:
        handle_error(e, "Failed to manage position")


def calculate_tunnel_bounds(data, period, deviation_factor):
    if len(data) < period:
        return pd.Series([np.nan] * len(data)), pd.Series([np.nan] * len(data))

    data = data.copy()
    data['close'] = pd.to_numeric(data['close'], errors='coerce')

    ema = calculate_ema(data['close'], period)
    rolling_std = data['close'].rolling(window=period).std()
    volatility = rolling_std * deviation_factor
    deviation = volatility / np.sqrt(period)
    upper_bound = ema + deviation
    lower_bound = ema - deviation

    return upper_bound, lower_bound

def calculate_position_size(account_balance, risk_per_trade, stop_loss_pips, pip_value):
    risk_amount = account_balance * risk_per_trade
    if stop_loss_pips == 0 or pip_value == 0:
        logging.error("Division by zero: stop_loss_pips or pip_value is zero in calculate_position_size")
        raise ZeroDivisionError("stop_loss_pips or pip_value cannot be zero")

    position_size_base = risk_amount / (stop_loss_pips * pip_value)
    position_size_lots = position_size_base / 100000  # Convert to lots

    position_size_lots = min(position_size_lots, 0.1)
    position_size_lots = max(position_size_lots, 0.01)

    logging.info(f"Calculated position size: {position_size_lots} lots")

    return round(position_size_lots, 2)

def generate_trade_signal(data, period, deviation_factor):
    if len(data) < period:
        logging.warning(f"Not enough data to generate trade signal. Required: {period}, Available: {len(data)}")
        return None, None

    upper_bound, lower_bound = calculate_tunnel_bounds(data, period, deviation_factor)

    last_close = pd.to_numeric(data['close'].iloc[-1], errors='coerce')
    upper_bound_last_value = upper_bound.iloc[-1]
    lower_bound_last_value = lower_bound.iloc[-1]

    logging.info(f"Generating trade signal with close price: {last_close}, upper bound: {upper_bound_last_value}, lower bound: {lower_bound_last_value}")

    if pd.isna(last_close) or pd.isna(upper_bound_last_value) or pd.isna(lower_bound_last_value):
        logging.error("One or more values are NaN, cannot generate trade signal.")
        return None, None

    buy_condition = last_close >= upper_bound_last_value
    sell_condition = last_close <= lower_bound_last_value

    logging.info(f"Buy condition: {buy_condition}, Sell condition: {sell_condition}")

    return buy_condition, sell_condition

def adjust_deviation_factor(market_conditions):
    if market_conditions == 'volatile':
        return 2.5
    else:
        return 2.0

def ensure_symbol_subscription(symbol):
    symbol_info = mt5.symbol_info(symbol)
    if not symbol_info:
        logging.error(f"Symbol {symbol} is not available.")
        return False

    if not symbol_info.visible:
        logging.info(f"Symbol {symbol} is not visible, attempting to make it visible.")
        if not mt5.symbol_select(symbol, True):
            logging.error(f"Failed to select symbol {symbol}")
            return False

    logging.info(f"Symbol {symbol} is already subscribed and visible.")
    return True
def run_strategy(symbols, mt5_init, timeframe, lot_size, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day, run_backtest, data=None, std_dev=None):
    try:
        logging.info("Starting strategy execution")
        total_profit = 0
        total_loss = 0
        max_drawdown = 0
        current_balance = starting_equity
        peak_balance = starting_equity

        for symbol in symbols:
            logging.info(f"Processing symbol: {symbol}")
            if data is None:
                current_data = get_current_data(symbol)
                logging.info(f"Current data for {symbol}: {current_data}")

                data = pd.DataFrame([{
                    'time': current_data['time'],
                    'open': current_data['last'],
                    'high': current_data['last'],
                    'low': current_data['last'],
                    'close': current_data['last'],
                    'volume': 0
                }])
            else:
                logging.info(f"Using provided data for {symbol}")

            period = 20
            market_conditions = 'volatile'
            deviation_factor = adjust_deviation_factor(market_conditions)

            logging.info("Calculating Wavy Tunnel indicators...")
            data['wavy_h'] = calculate_ema(data['high'], 34)
            data['wavy_c'] = calculate_ema(data['close'], 34)
            data['wavy_l'] = calculate_ema(data['low'], 34)
            data['tunnel1'] = calculate_ema(data['close'], 144)
            data['tunnel2'] = calculate_ema(data['close'], 169)
            data['long_term_ema'] = calculate_ema(data['close'], 200)

            logging.info("Detecting peaks and dips...")
            peak_type = 21
            peaks, dips = detect_peaks_and_dips(data, peak_type)
            logging.info(f"Detected peaks: {peaks[:5]} (total: {len(peaks)}), dips: {dips[:5]} (total: {len(dips)})")

            logging.info("Generating entry signals...")
            data['buy_signal'], data['sell_signal'] = zip(*data.apply(lambda x: check_entry_conditions(x, peaks, dips, symbol), axis=1))

            buy_condition, sell_condition = generate_trade_signal(data, period, deviation_factor)

            logging.info(f"Buy Condition: {buy_condition}, Sell Condition: {sell_condition}")

            if buy_condition or sell_condition:
                current_tick = get_current_data(symbol)
                logging.info(f"Latest price data for {symbol}: {current_tick}")

                trade_request = {
                    'action': mt5.TRADE_ACTION_DEAL,
                    'symbol': symbol,
                    'volume': lot_size,
                    'type': mt5.ORDER_TYPE_BUY if buy_condition else mt5.ORDER_TYPE_SELL,
                    'price': current_tick['bid'] if buy_condition else current_tick['ask'],
                    'sl': current_tick['bid'] - (1.5 * std_dev) if buy_condition else current_tick['ask'] + (1.5 * std_dev),
                    'tp': current_tick['bid'] + (2 * std_dev) if buy_condition else current_tick['ask'] - (2 * std_dev),
                    'deviation': 10,
                    'magic': 12345,
                    'comment': 'Tunnel Strategy',
                    'type_filling': mt5.ORDER_FILLING_FOK,
                    'type_time': mt5.ORDER_TIME_GTC
                }

                logging.info(f"Trade request: {trade_request}")
                result = execute_trade(trade_request)
                if result:
                    profit = trade_request['tp'] - trade_request['price'] if buy_condition else trade_request['price'] - trade_request['tp']
                    total_profit += profit
                    current_balance += profit
                    peak_balance = max(peak_balance, current_balance)
                    drawdown = peak_balance - current_balance
                    max_drawdown = max(max_drawdown, drawdown)
                    logging.info(f"Trade executed successfully. Profit: {profit:.2f}, Current Balance: {current_balance:.2f}, Drawdown: {drawdown:.2f}")
                else:
                    logging.error("Trade execution failed")

            manage_position(symbol, min_take_profit, max_loss_per_day, starting_equity, max_trades_per_day)

        logging.info("Strategy execution completed")
        return {
            'total_profit': total_profit,
            'total_loss': total_loss,
            'max_drawdown': max_drawdown
        }

    except Exception as e:
        handle_error(e, "Failed to run the strategy")
        return None

def get_data(symbol, mode='live', start_date=None, end_date=None, timeframe=mt5.TIMEFRAME_H1):
    """
    Retrieve data based on the mode. Can be used for both live and historical data.
    - mode: "live" or "backtest"
    - If backtest mode, start_date and end_date must be provided.
    """
    if mode == 'backtest':
        # Fetch historical data for backtesting
        return get_historical_data(symbol, timeframe, start_date, end_date)  # Directly call get_historical_data from metatrader
    else:
        # Fetch live tick data
        current_tick = get_current_data(symbol)
        if current_tick:
            live_data = pd.DataFrame([{
                'time': current_tick['time'],
                'open': current_tick['last'] if current_tick['last'] != 0 else (current_tick['bid'] + current_tick['ask']) / 2,
                'high': current_tick['ask'],
                'low': current_tick['bid'],
                'close': current_tick['last'] if current_tick['last'] != 0 else (current_tick['bid'] + current_tick['ask']) / 2,
                'volume': current_tick['volume'],
                'bid': current_tick['bid'],
                'ask': current_tick['ask']
            }])
            logging.info(f"Fetched live data for {symbol}: {live_data.tail()}")
            return live_data
        else:
            logging.error(f"Failed to retrieve live data for {symbol}")
            return None


def place_order(symbol, action, volume, price, sl, tp):
    try:
        logging.info(f"Preparing to place order for {symbol} - Action: {action}, Volume: {volume}, Price: {price}, SL: {sl}, TP: {tp}")
        order_type = mt5.ORDER_TYPE_BUY if action == 'buy' else mt5.ORDER_TYPE_SELL
        order = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": volume,
            "type": order_type,
            "price": price,
            "sl": sl,
            "tp": tp,
            "deviation": 10,
            "magic": 12345,
            "comment": "Tunnel Strategy",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_FOK,
        }
        logging.debug(f"Placing order: {order}")
        result = mt5.order_send(order)
        logging.info(f"Order send result for {symbol}: {result}")

        if result.retcode != mt5.TRADE_RETCODE_DONE:
            logging.error(f"Failed to place order for {symbol}: {result.comment}")
            return 'Order failed'
        logging.info(f"Order placed successfully for {symbol}")
        return 'Order placed'
    except Exception as e:
        logging.error(f"Exception occurred while placing order for {symbol}: {str(e)}")
        return 'Order failed'



def close_position(ticket):
    try:
        position = mt5.positions_get(ticket=ticket)
        if position:
            close_request = {
                'action': mt5.TRADE_ACTION_DEAL,
                'symbol': position[0].symbol,
                'volume': position[0].volume,
                'type': mt5.ORDER_TYPE_SELL if position[0].type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY,
                'position': ticket,
                'price': mt5.symbol_info_tick(position[0].symbol).bid if position[0].type == mt5.ORDER_TYPE_BUY else mt5.symbol_info_tick(position[0].symbol).ask,
                'deviation': 10,
                'magic': 12345,
                'comment': 'Tunnel Strategy Close',
                'type_time': mt5.ORDER_TIME_GTC,
                'type_filling': mt5.ORDER_FILLING_FOK,
            }

            logging.debug(f"Closing position with request: {close_request}")
            result = mt5.order_send(close_request)
            logging.info(f"Close position result: {result}")

            if result.retcode != mt5.TRADE_RETCODE_DONE:
                logging.error(f"Failed to close position: {result.comment}")
                return 'Close failed'
            return 'Position closed'
        return 'Position not found'
    except Exception as e:
        logging.error(f"Failed to close position: {str(e)}")
        return 'Close failed'

def check_broker_connection():
    if not mt5.terminal_info().connected:
        logging.error("Broker is not connected.")
        return False
    logging.info("Broker is connected.")
    return True

def check_market_open():
    current_time = datetime.now().time()
    market_open = dtime(0, 0)
    market_close = dtime(23, 59)
    if not (market_open <= current_time <= market_close):
        logging.error("Market is closed.")
        return False
    logging.info("Market is open.")
    return True

def get_fresh_tick_data(symbol):
    logging.info(f"Attempting to retrieve tick data for symbol: {symbol}")
    tick = mt5.symbol_info_tick(symbol)
    if tick:
        tick_data = {
            'symbol': symbol,
            'time': datetime.fromtimestamp(tick.time),
            'bid': tick.bid,
            'ask': tick.ask,
            'last': tick.last,
            'volume': tick.volume
        }
        logging.info(f"Retrieved tick data for {symbol}: {tick_data}")
        return tick_data
    else:
        logging.error(f"Failed to retrieve fresh tick data for {symbol}")
        raise ValueError(f"Failed to retrieve fresh tick data for {symbol}")

